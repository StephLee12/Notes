- [线性表](#%e7%ba%bf%e6%80%a7%e8%a1%a8)
  - [表的性质和概念](#%e8%a1%a8%e7%9a%84%e6%80%a7%e8%b4%a8%e5%92%8c%e6%a6%82%e5%bf%b5)
    - [1. 下一个关系](#1-%e4%b8%8b%e4%b8%80%e4%b8%aa%e5%85%b3%e7%b3%bb)
    - [2. 线性表的ADT](#2-%e7%ba%bf%e6%80%a7%e8%a1%a8%e7%9a%84adt)
    - [3. 线性表类型](#3-%e7%ba%bf%e6%80%a7%e8%a1%a8%e7%b1%bb%e5%9e%8b)
    - [4. 顺序表](#4-%e9%a1%ba%e5%ba%8f%e8%a1%a8)
    - [5. 链接表（链表）](#5-%e9%93%be%e6%8e%a5%e8%a1%a8%e9%93%be%e8%a1%a8)

# 线性表

## 表的性质和概念

### 1. 下一个关系

$$L=(e_0,e_1,\cdots,e_{n-1})$$

表元素之间存在一个基本关系，称为 **"下一个关系"**，"下一个关系"是二元组的集合。"下一个关系"是一种 **顺序关系，即线性关系**

$$\{<e_0,e_1>,<e_1,e_2>,\cdots,<e_{n-2},e_{n-1}>\}$$
每个元素都有一个唯一的前驱元素；除尾元素之外，都有唯一的后继元素

### 2. 线性表的ADT

- $List(self)$ 创建一个新表

- $is\_empty()$判断是否为空表

- $len(self)$获得$self$的长度

- $prepend(self,elem)$将元素$elem$作为第一个元素

- $append(self,elem)$将元素$elem$作为最后一个元素

- $insert(self,elem,i)$将$elem$作为表中第$i$个元素，其他元素的顺序不变

- $del\_first(self)$删除表中的首元素

- $del\_last(self)$删除表中的尾元素

- $del(self,i)$删除表中的第$i$个元素

- $search(self,elem)$查找元素$elem$在表中出现的位置，不出现时返回$-1$

- $forall(self,op)$对表中的每个元素执行操作$op$

### 3. 线性表类型

1. 顺序表
   1. 表中的元素顺序地存放在一大块存储区内 元素的关系由存储的顺序决定
2. 链表
   1. 表元素通过链接存在一系列 **存储块**中

### 4. 顺序表

1. 顺序表元素存储方式
   1. 将元素顺序存入到元素存储区，适用于一个表中保存的 **元素类型相同**，即元素的大小$size(e)$是**静态确定**的在表中安排等距同样大小的存储位置，此种方式可以直接映射到计算机内存和单元，计算位置的公式
       $$Loc(e_i)=Loc(e_0)\,+\,c*i$$

   2. 将实际数据元素另外存储，在顺序表中各存储单元中保存相应元素的**索引**——这是一种最简单的索引结构，适用于一个表中元素大小不统一的情况  

2. 顺序表基本操作及其时间复杂度
   1. 创建空表操作

        将表的容量$max$和表的当前元素$num$记录

   2. 简单判断操作

        表空时$num=0$

        表满时$num=max$

        这两个操作的时间复杂度都是$O(1)$

   3. 访问给定下标$\,i\,$的元素

        先检查$\,i\,$的值是否在合法范围内

        若位置合法通过公式即可算法元素的位置，即可访问，时间复杂度也是$O(1)$

   4. 遍历操作

        在遍历时用一个整数变量记录遍历到的位置

        每次访问 由"iii"可知，是$O(1)$的时间复杂度

        所以遍历操作的时间复杂度由元素个数有关——$O(n)$

   5. 查找给定元素$\,d\,$的位置

        这种操作称为**查找或检索**

        在没有其他信息的情况下，只能通过$\,d\,$与表中元素逐个比较，这种检索方式称为**线性检索**

        时间复杂度$O(n)$

   6. 查找给定元素$\,d\,$在位置$\,k\,$之后的第一次出现的位置

        与上述操作一致，只是从$\,k+1\,$位置的元素开始比较

        时间复杂度$O(n)$

   7. 变动操作：加入元素

        上述操作属于创建和访问操作，下面为变动线性表的操作

      1. 尾端加入新数据项

          时间复杂度$O(1)$

      2. 新数据存入元素存储区的第$\,i\,$个单元

          若操作**不要求维持原有元素的顺序**，可直接将原来位于$\,i\,$的元素放到其他以由元素之后，将$\,i\,$位置放入新的数据 时间复杂度为$O(1)$，注意要检查下标的合法性

          若操作要求保持原有元素的顺序(保序)，必须把$\,i\,$位置之后的元素逐一下移，时间复杂度为$O(n)$，注意要检查下标的合法性

   8. 变动操作：删除元素

      1. 尾端删除数据

          只需将元素计数值$num$减一，时间复杂度$O(1)$

      2. 删除位置$i$的数据

          和上文类似，先检查下标的合法性，也分为保序和不保序两种情况，同样的不保序的时间复杂度$O(1)$，保序的时间复杂度$O(n)$

      3. 基于条件的删除

          一般来说，时间复杂度$O(n)$

3. 顺序表操作的性质

     若顺序表中有$\,n\,$个元素,则表尾元素的下标为$\,n-1\,$,下标索引范围为$\,0\,$至$\,n-1\,$

     在下标$\,i\,$的位置加入一项新数据，需要移动$\,n-i\,$个元素 **此处应该是指的是“前插”** **顺序表的下标是从0开始的，所以前插会移动$\,n-i\,$个元素** 设在位置$\,i\,$加入元素的概率为$\,p_i\,$,执行该操作平均的元素移动次数
     $$\,\sum_{i=0}^{n} (n-i) p_i\,$$

     删除下标为$\,i\,$的数据项需要移动$\,n-i-1\,$个元素,设在位置$\,i\,$删除元素的概率为$\,p_i^{'}\,$,执行该操作平均的元素移动次数
     $$\,\sum_{i=0}^{n-1} (n-i-1) p_i\,$$

     比如下表的例子 要删除下标为$\,4\,$的元素$\,555\,$,需要移动的$\,6-4-1=1\,$个元素，即将下标为$\,5\,$的元素上移即可

     | 数据 | 下标  |
     | ---- | :---: |
     | 111  |   0   |
     | 222  |   1   |
     | 333  |   2   |
     | 444  |   3   |
     | 555  |   4   |
     | 666  |   5   |

     **顺序表的优点**

     $\,O(1)\,$时间按位置访问元素，元素在表里存储紧凑，在表元素存储区之外只需要$\,O(1)\,$空间存放少量的辅助信息，如表的容量$\,max\,$和表现在元素的个数$\,num\,$

     **顺序表的缺点**

     需要一块连续的内存，而且要先确定“容量大小”

4. 顺序表的结构

   顺序表是由**表中的元素**和**辅助信息**两部分组成的

   1. 两种顺序表的结构
      1. 一体式结构

          辅助信息和元素存储区是一块**连续的内存**，但是表创建之后，元素存储区的容量就固定了，此种结构只有**一个表对象**

      2. 分离式结构

          表对象只保存与整个表的辅助信息，实际元素存放在另一个独立的元素存储区对象里，两个对象通过链接关联

   2. 两种结构优缺

       一体式结构，如果不断向表中增加元素，元素存储区一定会满

       分离式结构不会存在上述问题，如果存储区要满了，再开一块更大的存储区存储表中的元素，只需要改变两个对象之间的链接，让表对象链接指向新的元素存储区，此种顺序表称为**动态顺序表**

   3. 动态顺序表的操作的时间复杂度

      动态顺序表的大小从$\,0\,$逐渐扩大到$\,n\,$

      1. 前端插入或定位插入

          i.e 前端插入就是在表的第一个元素前面插入新元素

          每次操作的开销都与表的长度有关，所以在大小从$\,0\,$逐渐扩大到$\,n\,$的过程中，总时间开销与$\,n^2\,$成正比，即整个表容量的增长过程的时间复杂度为$\,O(n^2)\,$

      2. 后端插入

          i.e 后端插入即在表尾插入新元素

          因为不需要移动，一次操作的时间复杂度是$\,O(1)\,$

          但要考虑到，表的当前的数据存储区终将被填满，所以当要换一块存储区时，要复制表中的元素，复制操作的时间复杂度为$\,O(m)\,$,其中$\,m\,$是当前表的元素个数

          出现了新的问题——**如何选定新的存储区的大小**，涉及到两个方面：**空闲存储单元的量** **替换存储的频度**

          替换的策略不同，时间复杂度不同，可以采取以空间换时间的策略，即**增加空闲存储单元的量来减小替换存储的频度**

          如下 一种简单的策略是：每次替换存储区时增加$\,10\,$个元素存储位置。假设表长从$\,0\,$不断增长到$\,1000\,$,则每加入十个元素就要换一次存储区，复制当时的所有元素，总的元素复制次数是
          $$10+20+30+\cdots+990=10\sum_{i=1}^{99} \,i\,=49500$$

          $\,49500\,$大约是$\,n^2/20\,$次复制，即虽然每次尾端插入的代价是$\,O(1)\,$，但是如果算入替换存储区后，执行一次插入操作的**平均代价**为$\,O(n)\,$

          这种策略的总开销较高，是因为**替换存储的频度**较高，下面这种策略——**每次存储区容量加倍**，会解决这个问题

          假设表元素个数从$\,0\,$不断增长到$\,1024\,$，存储区大小序列是$1，2，4，8，\cdots，1024$，总的元素复制次数是
          $$1+2+4+\cdots+512=\sum_{i=0}^{9} 2^i=1023$$

          复制次数**1023** 可以看到，元素的复制次数也是$\,O(n)\,$，采用此种策略，执行一次插入操作的**平均代价**为$\,O(1)\,$

          但是该策略也付出了代价，前一策略无论$\,n\,$取何值，元素存储区的最大空闲单元数是$\,9\,$;但后一种策略，空闲单元数大约为$n/2$,即**以空间换时间** 这是一种常用的思想

5. Python的list

     list是一种动态顺序表

     但是Python没有提供检查一个list对象的当前存储块容量的操作，也没有设置容量的操作，一切与容量相关的操作由Python解释器完成

6. 顺序表的总结

     - $\,O(1)\,$时间的定位元素访问，很多简单操作的效率也较高
     - 比较麻烦的是**变动操作 如加入/删除** 因为是连续排列的数据，所以会造成一连串的移动数据，开销可能会很大
     - 只有特殊的尾端插入/删除操作具有$\,O(1)\,$时间复杂度，而且插入操作复杂度还收到元素存储区的容量的限制。
     - 若线性表很大，需要一块很大的存储空间

### 5. 链接表（链表）

链表基本思想

- 把表中的元素分别存储在一批独立的存储块（称为表的**结点**）
- 从表中的任一个结点可以找到下一个结点
- 在前一结点用链接的方式显式地记录与下一结点之间的关联

1. 单向链表

     单项链表的结构如下图所示

     ![单向链表结构](snapshots\单向链表结构.PNG "单向链表结构")

     掌握一个单向链表，只需要知道这个表的首结点，即只需要用一个变量保存着这个表的**首结点的标识** 这个变量称为**表头指针**

     对于单向链表的结束，在表尾结点的链接域$\,next\,$设置一个不会作为结点对象标识的值（**空链接**），在$\,Python\,$中用系统常量$\,None\,$表示

     先定义一个简单的表结点类

     ```python
     class LNode:
          def _init_(self,elem,next_=None):
          self.elem = elem
          self.next = next_
     ```

     这里方法$\_init\_$的第二个参数名为$next\_$，是为了避免与$\,Python\,$中的标准函数$next$重名

   1. 基本单向链表操作
      1. 创建空链表

          将表头指针设置为空链接，Python中将表头指针设置为$\,None\,$

      2. 删除链表

          与语言环境有关，如C中每个结点都需要释放存储。

          但Python只需要将表指针赋值为$\,None\,$即可，解释器会自动回收不用的存储

      3. 判断表是否为空

          检查表头指针是否为$\,None\,$

      4. 判断表是否满

          一般链表不会满，除非用完了所有可用的存储空间

   2. 加入元素
      1. 表首端插入

          - 创建一个新结点并存入数据
          - 把原链表首结点的链接存入新结点的链接域$\,next\,$
          - 修改表头指针，让其指向新结点

          代码段示例

          ```python
          q = LNode(13) #创建一个新结点
          q.next = head #将新结点指向原链表的第一个结点
          head = q#将表头指针指向新结点
          ```

      2. 一般情况的元素插入

          在单向链表的某位置插入一个新结点，必须找到该位置之前的结点，修改它的$\,next\,$域，设指针$\,pre\,$指向前一结点，若已知前一结点，插入操作分为三步

          - 创建一个新结点并存入数据
          - 把$\,pre\,$所指结点的$\,next\,$域存入新结点的$\,next\,$域
          - 修改$\,pre\,$的$\,next\,$域，使其指向新结点

          代码段示例

          ```python
          q = LNode(13)
          q.next = pre.next
          pre.next = q
          ```

   3. 删除元素
         1. 删除表首元素

               只需修改表头指针，指向第二个结点，丢弃不用的结点被Python解释器自动回收

               代码段示例

               ```python
               head = head.next
               ```

         2. 一般情况的元素删除

               找到要删除元素所在结点的前一结点 设指针$\,pre\,$指向前一结点，修改$\,pre\,$的$\,next\,$域，使其指向删除结点的下一结点

   4. 扫描、定位和遍历
         1. 扫描

               从表头指针开始，沿着单向链表的链接方向，对表的内容进行检查，称为**扫描**

               伪代码如下

               ```python
               p = head
               while p is not None && other conditions:
                do some operations
                p = p.next
               ```

               辅助变量$\,p\,$称为扫描指针

         2. 定位
            1. 按下标定位

               链表首结点的元素的下标为$\,0\,$

               伪代码如下

               ```python
               p = head
               while p is not None && i > 0:
                do some operations
                i = i -1
                p = p.next
               ```

            2. 按元素定位

               $\,elem\,$域的元素内容作为$\,while\,$循环的条件

         3. 遍历

               完整的扫描称为遍历

               伪代码如下

               ```python
               p = head
               while p is not None：
                do some operations
                p = p.next
               ```

   5. 操作的复杂度

        - 创建空表$\,O(1)\,$
        - 删除表 **在Python中是$\,O(1)\,$**
        - 判断空表$\,O(1)\,$
        - 加入元素
          - 首端加入元素$\,O(1)\,$
          - 尾端加入元素$\,O(n)\,$ 因为单向链表要从表头开始遍历
          - 定位加入元素$\,O(n)\,$
        - 删除元素
          - 首端删除元素$\,O(1)\,$
          - 尾端删除元素$\,O(n)\,$
          - 定位删除元素$\,O(n)\,$
        - 扫描 定位 遍历 $\,O(n)\,$

   6. 求表的长度

        定义一个函数 遍历即可 时间复杂度$\,O(n)\,$

        ```python
        def length(head):
        p, n = head, 0
        while p is not None:
            n = n + 1
            p  = p.next
        return n
        ```

   7. 单链表类的实现

        上面定义了链表的结点类$\,LNode\,$

        ```python
        class LNode:
            def _init_(self,elem,next_=None):
            self.elem = elem
            self.next = next_
        ```

        在定义单向链表类之前 先定义一个异常类

        ```python
        class LinkedListUnderflow(ValueError)
        pass
        ```

        这里的``LinkedListUnderflow``是标准异常类``ValueError``的子类

        下面定义单向链表类

        ```python
        class LList:
            def __init__(self): #创建空表
                self._head = None

            def is_empty(self): #判断表是否为空
                return self._head is None

            def prepend(self,elem): #在表首加入元素
                self._head = LNode(elem,self._head)

            def pop(self): #删除表首元素
                if self._head is None: #空表 引发异常
                    raise LinkedListUnderflow("in pop")
                e = self._head.elem
                self._head =  self._head.next
                return e

            def append(self, elem): #在表尾加入元素
                if self._head is None:
                    self._head = LNode(elem)
                    return 
                p = self._head
                while p.next is not None:
                    p = p.next
                p.next = LNode(elem)

            def pop_last(self): #删除表尾元素
                if self._head is None: #空表
                    raise LinkedListUnderflow("in pop_last")
                p = self._head
                if p.next is None: #表只有一个结点
                    e = p.elem
                    self._head = None
                    return e
                while p.next.next is not None: #找到倒数第二个结点 即p.next是表尾结点
                    p = p.next
                e = p.next.elem #弹出最后一个结点的元素内容
                p.next = None
                return e

            def find(self,pred): #查找
                p = self._head
                while p is not None:
                    if pred(p.elem):
                        return p.elem
                    p = p.next

            def printall(self): #打印所有结点
                p = self._head
                while p is not None:
                    print(p.elem, end='')
                    if p.next is not None:
                        print(', ',end='')
                    p = p.next
                print('')
            def for_each(self,proc): #表的遍历
                p = self._head
                while p is not None:
                    proc(p.elem)
                    p = p.next

            def elements(self): #生成器函数
                p = self._head
                while p is not None:
                    yield p.elem
                    p = p.next

            def filter(self,pred): #筛选生成器函数
                p = self._head
                while p is not None:
                    if pred(p.elem):
                        yield p.elem
                    p = p.next
        ```

        关于上述类的几点解释

        - 其中关于``yield``，是python中的一个关键字，其相关解释见此链接[yield](https://blog.csdn.net/mieleizhi0522/article/details/82142856)
        - 线性表一类的对象称为**汇集(collection)对象**,它们本身是对象，其中又包含着一组元素对象 对于汇集对象，逐个使用其中的元素的操作称为**遍历**
        - 上面的方法``for_each``是传统的遍历方式，以一个操作``proc``作为参数，将其作用到汇集对象的每个元素上 而对于Python对汇集对象提供的遍历机制是迭代器,即``yield``，对应类的方法``elements``和``filter`` 可以在代码里写

            ```python
            for x in list1.elements():
                print(x)
            ```

        其中方法``filter``是改良了方法``find`` 因为``find``只能取满足``pred``的第一个元素，但表里可能又很多个这样的元素

        - 在代码中又添加了一些新的功能，见代码

   8. 单链表的简单变形
      1. 增加表尾的引用域

            上述单链表表尾加入元素的效率很低，要从表头开始查找

            所以可以在表对象中增加一个表尾结点的引用域，有了这个引用域，常量时间就可以找到表尾结点

      2. 通过继承和扩充定义新链表类

            面向对象编程 允许基于已有类(基类)定义新类(派生类)

            这种派生类会继承基类的所有功能，并且可以定义新的数据域和新的方法，还可以重新定义基类中的方法

            ```python
            class LList1(LList):
                pass
            ```

   9. 循环单链表

        表尾结点的``next``域不为``None``,而是指向表的第一个结点

        两种表示方式如下图

        ![循环单链表](snapshots\循环单链表.PNG "循环单链表")

        详见代码

   10. 双链表

        在原有的``elem``和``next``域基础上再增添``prev``域，表示与前一结点的链接

        **详见代码**

   11. 循环双链表

        **详见代码**

   12. 链表反转

        **详见代码**

   13. 链表排序

        **详见代码**

   14. 链表总结

        - 单链表 对于表首的操作均为 $\,O(1)\,$ 而尾端以及表中都是$\,O(n)\,$
        - 循环单链表 遍历时注意循环的判断条件
        - 双链表 我觉得很NB

        链表的优点

        - 结点的顺序由链接关系决定，链接可以修改，因此表的结构很容易调整和修改
        - 不需要修改结点里的数据元素或者移动它们，只通过修改结点之间的链接，就能修改表的结构和数据排列方式

   15. Josephus问题
       1. list 将退出的元素置0
       2. list顺序表 将退出的元素pop出来
       3. 循环单链表
