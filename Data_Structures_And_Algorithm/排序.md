- [排序](#%e6%8e%92%e5%ba%8f)
  - [排序基本概念](#%e6%8e%92%e5%ba%8f%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5)
  - [简单排序算法](#%e7%ae%80%e5%8d%95%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95)
    - [插入排序](#%e6%8f%92%e5%85%a5%e6%8e%92%e5%ba%8f)
    - [选择排序](#%e9%80%89%e6%8b%a9%e6%8e%92%e5%ba%8f)
    - [交换排序(冒泡排序)](#%e4%ba%a4%e6%8d%a2%e6%8e%92%e5%ba%8f%e5%86%92%e6%b3%a1%e6%8e%92%e5%ba%8f)
  - [快速排序](#%e5%bf%ab%e9%80%9f%e6%8e%92%e5%ba%8f)
  - [归并排序](#%e5%bd%92%e5%b9%b6%e6%8e%92%e5%ba%8f)
  - [其他排序方法](#%e5%85%b6%e4%bb%96%e6%8e%92%e5%ba%8f%e6%96%b9%e6%b3%95)
    - [分配和排序](#%e5%88%86%e9%85%8d%e5%92%8c%e6%8e%92%e5%ba%8f)
    - [多轮分配和排序(基数排序/桶排序)](#%e5%a4%9a%e8%bd%ae%e5%88%86%e9%85%8d%e5%92%8c%e6%8e%92%e5%ba%8f%e5%9f%ba%e6%95%b0%e6%8e%92%e5%ba%8f%e6%a1%b6%e6%8e%92%e5%ba%8f)
  - [排序算法总结](#%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95%e6%80%bb%e7%bb%93)

# 排序

## 排序基本概念

👉内排序：待排序的记录全部保存在内存

👉外排序：针对外存数据的排序工作(i.e. **归并排序算法**是大多数外排序算法的基础)

👉基于key比较的排序问题，复杂度的下界是$\,O(n\log n)\,$

👉由于排序是对已有序列做的一项操作，在分析排序算法的空间复杂度时，考虑的是为了执行这个算法所需要的空间。算法执行时使用的空间是临时性的辅助空间，用过之后就可以释放

👉对于内排序，希望空间复杂度是常量的，常量的空间开销意味着排序工作可以在**原序列**中完成，只需要几个简单变量作为操作中的临时存储。具有这种性质的算法称为**原地排序算法**

👉排序算法的稳定性：

Example：

![排序算法确定性例子](Snapshots\排序算法确定性例子.PNG "排序算法确定性例子")

即若要按某个标准排序，序列可能无序，但是序列的指标可能不止有一个，如这里的年级。

如果排序算法可以保证：对于待排序序列里**任一对key相同**的数据$\,R_i,R_j\,$,在排序完成后的序列里$\,R_i,R_j\,$的前后顺序不变，则称这个算法使稳定的

👉排序算法的分类

- 插入排序
- 选择排序
- 交换排序
- 分配排序
- 归并排序
- 外部排序

## 简单排序算法

### 插入排序

[单链表的排序算法``sort_1``](线性表.md)

👉算法思想：

元素插入到前面已经排序的序列

👉算法分析

👉算法的空间复杂度：

只使用了两个简单的变量，空间复杂度是常量级

👉算法的时间复杂度：

外层循环总要进行``n-1``次。

内层循环与实际的比较情况有关：

最坏的情况是**每次处理的元素都比前面所有元素小**，这个元素就会移到最前面，此时内层循环体的执行次数为
$$
  1 + 2 + \cdots + (n-1) = n \times (n-1) /2
$$

最好的情况是**序列已经有序**，始终不进入内层循环

所以最坏情况下算法的复杂度是$\,O(n^2)\,$,最好情况的时间复杂度是$\,O(n)\,$,所以这个算法具有**适应性**

但是考虑算法的**平均时间**：

假设一个元素插入已排序列的每个元素的概率相同，内层循环的每次进行比较的次数是``j/2``，
$$
  [1 + 2 + \cdots + (n-1)] /2 = n \times (n-1) /4
$$
所以算法的复杂度仍然是$\,O(n^2)\,$

注意语句``lst[j-1].key > x.key``,说明一旦发现前面的元素和当前的key值相等，就不再移动元素，这种做法保证了key相同的元素不会交换位置，所以这个算法具有**稳定性**

👉 算法的变形

对于当前元素插入到前面已排序列，可以采用二分法插入，但是由于要进行移动，还是改变不了算法的时间复杂度

👉算法的改进——希尔排序(Shell Sort)

不稳定

也是采用分段的思想，在每一段中使用插入排序的方法

空间复杂度常量级

时间复杂度

最坏情况 $\,O(n^2)\,$

最好情况$\,O(n\log^2 n)\,$

平均情况$\,O(n^{1.5})\,$

### 选择排序

👉感觉像是插入排序逆过来，向后搜索，插入排序是向前搜索

👉算法分析

空间复杂度仍为常量级

时间复杂度：

与插入排序不同，内层循环是一定要执行的，因此不存在最坏或最好的情况，所以这个算法没有适应性，时间复杂度为$\,O(n^2)\,$

关于算法的**稳定性**：

将最小元素放到已排序列的尾端不会破坏稳定性，因为向后检索到的最小元素，即使key相同，也必然是第一个，不会破坏key值相同的元素的先后顺序。

但是将本来的元素``lst[i]``交换到最小元素的位置可能会破坏与``lst[i]``相同的key值的元素的先后顺序，所以算法没有稳定性

所以自然也有解决方案：找到最小元素的位置``k``后，将此元素之前未排序的元素逐个后移，腾出的空位放``lst[i]``，但是也增加了开销

👉害，整了那么多，这个算法⑧行

👉算法改进

原算法的**致命缺点**：选择效率太低，做了很多重复的操作

提出了[堆排序](二叉树与树.md)

初始建堆时间$\,O(n)\,$,弹出堆顶元素之后恢复堆的时间开销不超过$\,O(\log n)\,$

👉堆排序的时间开销$\,O(n\log n)\,$

但是，**堆排序最大的问题是不稳定**，在**初始建堆**和**向下筛选**的过程中，元素都沿着堆中(二叉树)的路径移动，在这种移动中，很可能出现相同关键码记录的顺序被交换的情况。

而且，堆排序没有适应性，因为每次弹出堆顶元素后，总是用最后一个元素进行向下筛选，经常导致较长的筛选路径

👉注意，大顶堆得到的是递增序列，小顶堆得到的是递减序列

### 交换排序(冒泡排序)

👉基本思想：通过交换元素**消除逆序**

![冒泡排序](Snapshots\冒泡排序.PNG "冒泡排序")

每一次外层循环的执行，可以保证一个最大的元素移到未排序部分的最后

通过``n-1``遍扫描，一定可以完成排序

👉算法改进

冒泡排序需要做满``n-1``扫描，只是当最小的元素恰好出现在最后才会出现这种情况。在其他情况下，不需要进行``n-1``次的扫描，如果在一次扫描中没有遇到逆序的情况，就可以停止排序了

这样做可能提高效率，并且使算法有了适应性

👉算法分析

空间复杂度常量级

时间复杂度

最坏情况 $\,O(n^2)\,$,最好$\,O(n)\,$，平均复杂度$\,O(n^2)\,$

## 快速排序

👉基本思想

- 选择一种标准，把被排序序列中的数据按照这个标准分为**大小两组**。显然从整体的角度，这两组的顺序已定，较小一组的数据应该在排在前面
- 采用同样的方式，递归地分别划分得到的这两组数据，并继续递归地划分下去
- 划分总是得到越来越小的分组，如此递归下去直到每个组的数据中最多包含一个数据，整个序列排序完成

👉选取标准

考虑最简单的划分方式：**取序列中第一个数据，以其key为标准划分其他数据**，将key小的数据移到左边，key大的数据移到右边。划分完成后，**表中会留下一个空位**，这是作为标准的数据的位置

之后用同样的方式处理两段数据，进行递归处理。当一个段中只有一个元素或者没有元素时，该段的排序完成，完成所有分段的排序则完成序列的排序

这样的处理，每次递归不停的分成两段，是**二叉树形式**的递归调用

👉 一次划分的实现

由于是递归实现，搞清一次怎么划分即可

![快速排序](Snapshots\快速排序.PNG "快速排序")

设序列的第一个数据为$\,R\,$,它的key记为$\,K\,$

图a是划分中序列的一般状态

完成划分，**要利用好表中的空位**。

👉取出R之后，序列的左边出现了一个空位，**这时从右端开始检查**，将发现的第一个key小的数据移到左边的空位，这一个迁移操作也使右边留下一个空位，接着**从左端开始检查**，将发现的第一个key大的数据移到右边的空位，如此交替进行

算法中利用两个下标变量``i``和``j``，其初值分别是序列的第一个数据和最后一个数据的位置。在划分过程中，**它们的值交替作为空位和下一被检查数据的下标**

👉算法步骤

- 从右向左逐个检查``j``一边的记录，检查中``j``值不断减一，直到找到第一个key值小于K的数据，将其存入``i``所指的空位。**移动之后位置``j``变为空位，``i``值加一指向下一个需要检查的数据**
- 从左向右逐个检查``i``一边的记录，检查中``i``值不断加一，直到找到第一个key值大于K的数据，将其存入``j``所指的空位。**移动之后位置``i``变为空位，``j``值减一指向下一个需要检查的数据**
- 重复交替上述两个操作，直到``i``不再小于``j``为止
- 划分结束时``i==j``，指向表中的空位，将R存入该空位，一次划分完成
- 对一次划分完成后两边子序列按同样方式递归处理

👉算法分析

时间复杂度

最坏情况$\,O(n^2)\,$,平均时间复杂度为$\,O(n\log n)\,$

若快排排序低效，根源是划分标准没有取好

空间复杂度

要考虑的就是**递归的深度**，最坏情况是$\,O(n)\,$(参考二叉树，如果一条路径太长，性能趋于线性)

可以通过在程序中引用一个栈，采用非递归的方式保存未处理分段信息，用非递归的方式实现快排。如果每次划分后，把较长分段的信息入栈，先处理较短的分段，记录分段信息的栈的深度就不会超过$\,O(\log n)\,$,可以减少空间开销

## 归并排序

👉基本方法

- 初始时，把待排序序列中的n个数据看成n个有序子序列，即每个子序列长度为1
- 把当时序列组里的有序子序列两两归并，完成一遍后序列组里的排序序列个数减半，每个子序列长度加倍
- 重复上述操作，最终得到一个长度为n的有序序列

这种归并方法也称为**二路归并排序**

对于归并排序，实现**原地排序**不容易。

这里，另开一个与原序列相等长度的表，把一遍归并的结果放在此表，再次归并的结果放回原表，这样反复操作。

显然，这里需要$\,O(n)\,$的辅助空间，**这就是计算机中常用的以时间换空间的策略**

👉算法设计

归并算法用三层实现：(即三个函数)

- 最下层：实现表中**相邻的一对**有序序列的归并工作，并将归并的结果存入另一个顺序表的相同位置
- 中间层：基于最下层的操作，实现对整个表里**各对有序序列**的归并，完成一遍归并
- 最高层：反复执行中间层操作，每完成一遍归并后骄傲换两个表的地位，直至整个表里只有一个有序序列时排序完成

👉算法分析

空间复杂度$\,O(n)\,$

时间复杂度

在做完第k遍归并后，有序子序列的长度变为$\,2^k\,$,所以归并遍数不会多于$\,\log_2 n + 1\,$，在每遍归并做的比较次数是$\,O(n)\,$,所以时间复杂度是$\,O(n\log n)\,$

## 其他排序方法

👉不基于key值比较，而是基于**一种固定位置的分配和收集**

### 分配和排序

👉如果关键码**只有很少的几个值**，可以采用下述的直观的排序方式：

- 为每个关键码值设定**一个桶**(即是能容纳任意多个数据的容器，可以连续表或链表，[参考桶散列表](字典和集合.md)
- 排序时简单地根据key把数据放入相应的桶
- 存入所有数据，顺序收集各个桶中的数据，得到了排序的序列

桶排序是很稳定的

### 多轮分配和排序(基数排序/桶排序)

通过多轮分配和收集，对**元组**key进行排序

👉Ex

![基数排序1](Snapshots\基数排序1.PNG "基数排序1")

- 从最高位的key开始排序，称为MSD(Most Significant Digit first)。得到的序列如下图所示，下一步考虑**各子序列的排序**(基于key的下一元素)，然后考虑子序列的子序列，直到所有最小的子序列都完成排序。**但是MSD麻烦的地方在于，需要考虑越来越多的子序列**

![基数排序2](Snapshots\基数排序2.PNG "基数排序2")

- 从最低位的key开始排序，称为LSD(Least Significant Digit first)，如下图所示。分配一遍后，将数据顺序收集，各key的最后一位分段递增。如果**再按key的中间元素分配和收集**，再得到中间位相同每个分段，仍然可以保证最后一位递增。再收集之后，得到的序列按后两位递增排序

![基数排序3](Snapshots\基数排序3.PNG "基数排序3")

由上分析，采用LSD

如果每位key都是数字，上述key元组就像是按某种进制表示的一个整数，排序过程就是从低到高逐位进行分配和收集。这样的处理过程就像是按基数逐位处理，这种多轮分配排序也称**基数排序**

[书上说的看不明白，看这个链接](https://www.jianshu.com/p/a1012fab9161)

桶可以采用连续表或者链表

## 排序算法总结

![排序算法](Snapshots\排序算法.PNG "排序算法")