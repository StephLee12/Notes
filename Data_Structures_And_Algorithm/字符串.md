- [字符串](#%e5%ad%97%e7%ac%a6%e4%b8%b2)
  - [基本概念](#%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5)
  - [字符串的实现](#%e5%ad%97%e7%ac%a6%e4%b8%b2%e7%9a%84%e5%ae%9e%e7%8e%b0)
  - [字符串匹配(子串查找)](#%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%8c%b9%e9%85%8d%e5%ad%90%e4%b8%b2%e6%9f%a5%e6%89%be)
  - [正则表达式](#%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f)

# 字符串

## 基本概念

- 字符序

    **字符集上有一种确定的序关系**

    类似与$\,AlphabetOrder\,$从$\,A\,$开始，即对于任意的两个字符，它们可能相等，可能某个字符排在另一字符之前(用“$\,<\,$”表示)，这样字符集中的任意两个字符有三种关系$\,<,=,>\,$

- 字典序

    **基于字符序定义**

    对于字符串
    $$s_1 = a_0 a_1 \cdots a_{n-1}$$
    $$s_2 = b_0 b_1 \cdots b_{n-1}$$
    如果存在一个$\,k>=0\,$使对于任何$\,i<k\,$都有$\,a_i = b_i\,$,但$\,a_k < b_k\,$

    或$\,n<m\,$且对任何$\,0<=i<n\,$都有$\,a_i = b_i\,$

    若满足上述两种情况中的一种，则$\,s_1 < s_2\,$

    例如：字符串$\,abc\,$小于$\,add\,$,也小于$\,abcd\,$

- 字串关系

    串$\,s_1\,$与串$\,s_2\,$中的一个连续片段相同

    **注意如果$\,s_1\,$在串$\,s_2\,$中出现多次，不同次的出现可能不是独立的，而是相互重叠的** 如$\,babb\,$在$\,babbabbbbabb\,$，第一次出现在位置0 第二次在位置3 第三次在位置8

    前缀和后缀是两种特殊的字串，字面意思

- 有用的串运算可以参考python的$\,str\,$类型

- 字符串$\,ADT\,$
  - $\,String(self,sequence)\,$基于字符序列建立一个字符串
  - $\,is\_empty(self)\,$判断本字符串是否为空串
  - $\,len(self)\,$获取字符串的长度
  - $\,char(self,index)\,$获取字符串中某一位置的字符
  - $\,substr(self,a,b)\,$获取字符串中$\,[a:b]\,$位置的字串
  - $\,match(self,string)\,$获取串$\,string\,$在本字符串中第一个出现的位置
  - $\,concat(self,string)\,$将本字符串和另一字符串$\,string\,$拼接
  - $\,subt(self,str1,str2)\,$将本字符串里的子串$\,str1\,$都替换为字符串$\,str2\,$

## 字符串的实现

- 字符串是字符的线性序列，可以采用线性表的实现技术，有两个需要注意的问题，**字符串内容的存储**——顺序表和链接表 **串结束的表示**——用一个专门的数据域记录字符串的长度或用一个特殊编码表示串结束，后者需要保证该编码不代表任何字符
- Python标准类型$\,str\,$，对象创建后内容和长度都不变化，采用的是**一体式顺序表**

## 字符串匹配(子串查找)

假设有两个串
$$t = t_0 t_1 \cdots t_{n-1}$$
$$p = p_0 p_1 \cdots p_{m-1}$$

字符串匹配就是在$\,t\,$中查找与$\,p\,$相同的字串的操作，称$\,t\,$为目标串，$\,p\,$为模式串，通常$\,m<<n\,$

但实际上$\,n\,$可能非常大，$\,m\,$也可能有一定的规模，所以匹配算法的效率非常重要

- 朴素的串匹配算法

    从左到右逐个字符匹配，发现不匹配时，转去考虑目标串里的下一个位置是否与模式串匹配

    ![朴素字符串匹配](snapshots\朴素字符串匹配.PNG "朴素字符串匹配")

    ```python
    def naive_matching(t,p):
        m,n = len(p), len(t)
        i,j = 0,0
        while i < m and j < n:
            if p[i] == t[j]:
                i,j = i + 1 ,j + 1
            else:
                i,j = 0, j - i + 1
        if i == m :
            return j -i
        return -1
    ```

    上述算法的效率很低，主要因素是出现**回溯**

    即匹配中遇到一对字符不同时，模式串$\,p\,$将右移一个字符位置，随后的匹配回到模式串开始(即代码中$\,i = 0\,$)

    最坏的情况是每一次比较都在模式串的最后遇到了字符不匹配的情况，这种情况下总共要做$\,n-m+1\,$次比较，总的比较次数为$\,m(n-m+1)\,$,所以这个算法的时间复杂度是$\,O(m*n)\,$

    效率低的根源在于：把每次字符比较看作完全独立的操作，没有利用字符串本身的特点，也没有尽量利用前面已经做过的字符比较中得到的信息  

    从数学上看，这样进行朴素匹配，相当于目标串和模式串里的字符都是完全随机的量，而且有无穷多种可能取值，因此任意两次字符比较相互无关也不可借鉴。但实际情况是，字符串中的字符取值来自一个有穷集合，而且每个串都具有确定的有穷长度 **特别是模式串** 通常不太长，且可以在匹配中反复使用

- KMP算法(无回溯串匹配算法)

    若先对模式串做一些分析，记录得到的有用信息(如哪些位置的字符相同或不同)，就可能避免一些不必要的匹配，提高匹配效率。这种做法是实际匹配前的静态预处理

    KMP算法的精髓就是开发了一套**分析和记录模式串信息的机制**，借助得到的信息加速匹配

    下图是朴素匹配和KMP匹配的对比

    ![朴素和KMP对比](snapshots\朴素和KMP对比.PNG "朴素和KMP对比")

    在状态0匹配到第一个c失败，**已知模式串的前两个字符不同**，KMP算法直接将模式串右移两个位置

    在状态1，匹配到模式串最后的c处失败，**已知模式串c之前是a，模式串的首字符也是a，且两个a之间没有字符a 所以不可能有匹配** 所以**直接将模式串的b移到刚才匹配c失败的位置(注意:前面的字符a肯定匹配，无需再试)**

    可见KMP算法的效率比朴素匹配高许多

    KMP算法的基本思想：**匹配中不回溯**。如果匹配中用模式串里的$\,p_i\,$匹配到了某个$\,t_j\,$时失败了，则要找到某个特定的$\,k_i(0<=k_i<i)\,$,下一步用模式串中字符$\,p_{k_i}\,$与目标串的$\,t_j\,$比较。直白的说，在匹配失败时把模式串右移若干位置，用模式串里匹配失败字符之前的某个字符与目标串中匹配失败的字符比较

    问题在于如何确定右移的$\,k_i\,$

    要注意到。在$\,p_i\,$匹配失败时，所有的$\,p_k(0<=k_i<i)\,$都已匹配成功，也就是说，在目标串中$\,t_j\,$前的$\,i\,$个字符即为模式串的前$\,i\,$个字符。 **这样确定右移的位置就与目标串无关了，只需根据模式串本身分析，即模式串中的每一个字符，都有与之对应的下标$\,k_i\,$**

    若一个模式串$\,p\,$长度为$\,m\,$，建立一个长为$\,m\,$的表``pnext``，用表元素``pnext[i]``记录与$\,i\,$对应的$\,k_i\,$值

    **注意一种特殊情况，若匹配失败时，无法得到有用的信息，则下一步就要用$\,p_0\,$匹配$\,t_{j+1}\,$，此种情况，在``pnext[i]``中存入``1``,显然有``pnext[0]==-1``**

    现在假设已经得到``pnext``表，KMP的匹配循环很好写出

    ```python
    while j < n and i < m :
        if i == -1 or p[i] == t[j]:
            i,j = i+1,j+1
        else:
            i = pnext[i]
    ```

    基于循环的匹配函数如下

    ```python
    def matching_KMP(t,p,pnext):
        i,j = 0,0
        m,n = len(p),len(t)
        while j < n and i < m :
            if i == -1 or p[i] == t[j]:
                i,j = i+1,j+1
            else:
                i = pnext[i]
        if i == m:
            return j - 1 #匹配成功 返回下标

        return -1 #没有匹配成功，返回特殊值
    ```

    下面分析该算法的复杂度

    整个循环中在第一个分支$\,j\,$的值是递增的，递增的总次数不会多于``len(t)``，对于另一分支，``i=pnext[i]``使``i``的值减小，但第一个分支会保证``i``的值最小为-1，一旦等于-1，下一次循环会进入第一个分支，所以执行第二个循环的次数不会``i``值递增的次数。由此可知，复杂度为$\,O(n)\,$

    下面考虑构造``pnext``表

    ![表pnext构造](snapshots\表pnext构造.PNG "表pnext构造")

    在$\,t_j\,$和$\,p_i\,$匹配失败后，找到位置$\,k\,$，下次匹配用$\,p_k\,$与$\,t_j\,$比较，如上图(2)所示，模式串中的子串$\,p_0\cdots p_{i-1}\,$应该与字串$\,p_{i-k}\cdots p_{i-1}\,$匹配，而这两个子串分别为$\,p_0\cdots p_{i-1}\,$的长度为$\,k\,$的前缀和后缀。

    所以确定$\,k\,$的问题变成了确定$\,p_0 \cdots p_{i-1}\,$的相等前缀和后缀的长度 显然$\,k\,$值越小，移动的越远，为了不错过可能的匹配，要寻找长度最长的相等前缀和后缀(可以是空串,但不能是串本身) 若最长相等前后缀长度为$\,k(0<=k<i-1)\,$,模式串应该右移$\,i-k\,$位，将``pnext[i]=k``设置为k

    下面构造``pnext``表 通过一种递推算法

    已知``pnext[0]=-1``和直至``pnext[i-1]``的已有值求``pnext[i]``的算法：

    $step 1$ 假设``pnext[i-1]=k-1`` 如果$\,p_i = p_k\,$,那么$\,p_0\cdots p_t\,$的最长相等前后缀的长度就是$\,k\,$，令``pnext[i]=k``，将$\,i\,$值加一后继续递推

    $step 2$ 如果不相等，将$\,k\,$设置为``pnext[k]``的值,**因为``pnext[k]``是``k``之前的字符串的最长前后缀长度 即p[k]之前的pnext[k]位和从一开始的pnext[k]位是相同的 所以``k``直接从``pnext[k]``开始匹配，这样效率更高** [kmp参考链接](https://www.zhihu.com/search?q=kmp%E7%AE%97%E6%B3%95&utm_content=search_suggestion&type=content)

    $step 3$ 如果$\,k\,$的值等于-1(这个值一定是由于第2步，来自于``pnext``)，那么$\,p_0\cdots p_t\,$的最长相同前后缀的长度就是0，设置``pnext[i]=0``，将$\,i\,$值加一后继续递推

    代码如下 注意**代码是先将``i``和``k``递增，再设置``pnext[k]``的值**

    ```python
    def gen_pnext(p):
        i ,k ,m = 0 , -1 , len(p)
        pnext = [-1] * m #初始化pnext表全为1
        while i < m -1:
            if k == -1 or p[i] == p[k]:
                i, k  = i+1, k+1
                pnext[i] = k
            else:
                k = pnext[k]
        return pnext
    ```

    下面对``pnext``生成算法进行改进 **没太看懂**

    ```python
    def gen_pnext(p):
        i ,k ,m = 0 , -1 , len(p)
        pnext = [-1] * m #初始化pnext表全为1
        while i < m -1:
            if k == -1 or p[i] == p[k]:
                i, k  = i+1, k+1
                if p[i] == p[k]:
                    pnext[i] = pnext[k]
                else:
                    pnext[i] = k
            else:
                k = pnext[k]
        return pnext
    ```

    一次KMP算法的执行包括构造``pnext``表和实际匹配，设模式串和目标串长度分别为``m``和``n``，KMP算法的时间复杂度为$\,O(m+n)\,$，在多数情况下有$\,m<<n\,$,因此可以认为这个算法的时间复杂度为$\,O(n)\,$

- 字符串匹配的问题

    上面讨论的字符串匹配是最简单的情况，匹配基于最简单的字符比较，其中的模式串就是普通的字符串，所做匹配是在目标串里查找模式串的子串

    然而实际上，需要查找的并不是某个特定的字符串，而是**具有某种形式**的字符串。

    如一个文本中所有双引号括起的词语或书名包括“数据结构”的词所有书籍

    在这种匹配需求下，**需要考虑的不是一个模式串，而是一组模式串(可能有穷，可能无穷)**

    上面讨论的模式串是**模式**这个概念的特例:①模式的形式的普通字符串②每个模式描述的字符串集合都是单元素集合，即这个字符串本身③匹配的条件是字符串相等

    对于一般的模式，也需要回答这三个问题:模式的形式是什么，描述的字符串集合如何确定，如何做匹配。

    其中描述字符串集合需要**一种严格的描述方式**，这种方式应该能描述很多有用的字符串集合。一种**系统化**的描述方式，就是一种描述**串模式**的语言(简单字符串匹配的**模式语言**就是字符串本身)

    其中如何做匹配:尽量实现高效的匹配算法

## 正则表达式

[RegularExpression](https://regexone.com/)

- Lesson 1

    **Everything is essentially a character**. We acutally write **patterns** to match a specific sequence of characters. Most patterns use normal ASCII

    **metacharacter**

    for example, **\d** can be used in place of any **digit** from 0 to 9. The preceding slash distinguishes it from the simple **d** character and indicates that it is a **metacharacter**

    and **\D** can be used in place of any **None-digit character**

- Lesson 2 The Dot

    The metacharacter **.**(dot) can match any single character(letter,digit,whitespace,everything). But if you want to match **.**(period), you need to add a slash **\\** in front of **.**

- Lesson 3 Matching specific characters

    The dot metacharacter from lesson 2 is pretty powerful, but sometimes too powerful. If we are matching phone numbers, we don't want to validate letters as being a valid number

    If we want to match specific characters, we can define them inside **square brackets**. For example, the pattern [abc] will only match **a single** a,b or c letter

- Lesson 4 Excluding specific characters

    We use a similar expression that **excludes specific characters** using **the square brackets and the **^**(hat)**. For example, the pattern [^abc] will match any **single** character **except for** the letters a,b or c

- Lesson 5 Character ranges

    What if we want to match a character that can be in a sequential range characters?

    We can use **square bracket notation and dash** to achieve that. The dash indicates a character range. For example, the pattern [0-6] will only match any **single** digit character from 0 to 6.
    And likewise, [^n-p] will only match any single character **except** for letters n to p

    Multiple character ranges can also be used in the same set of brackets. For example, the **metacharacter \w** is equivalent to the character range **[A-Za-z0-9]**, which can match any alphanumeric character. And **\W** can match any Non-alphanumeric character.

- Lesson 6 Catching some zzz's

    We've so far learned how to specify the range of characters we want to match, how about the **number** of **repetitions** of characters we want to match. We don't want to use "\d\d\d" to match exactly three digits, because it's not convenient

    We can use **curly braces** notation to specify how many repetitions of each character. For example, **a{3}** will match the "a" character three times. And **certain regular expression engines** will allow you to specify a **range for this repetition** such that **a{1,3}** will match the "a" character no more than three times, but no less than once.

    This quantifier can be used with any character, or special metacharacters

- Lesson 7 Mr.Kleene, Mr.Kleene

    A powerful concept in regular expressions is to match **an arbitrary number of characters**.

    One way to express such a pattern is to use the **Kleene Star** and the **Kleene Plus**, which represents either **0 or more** or **1 or more** of the character that it follows.

    i.e. **Kleene** are either sets of strings or sets of symbols or characters.

    For example, **\d*** is to match any number of digits but there can be no digit. On the countary, **\d+** ensures that the input string has at least one digit

    The two quantifiers can be used with any character or special metacharacters. For example, **a+** means **one or more** a's, **[abc]+** means **one or more of any a,b or c character**, **.*** means **zero or more of any character**.

- Lesson 8 Characters optional

    In Lesson 7, the Kleene star and plus allow us to match repeated characters in a line.

    In this lesson, we introduce another common quantifier **?**(question mark), which is a metacharacter. This metacharacter allows you to match **either zero or one of the preceding character or group**. For example, the pattern **ab?c** will match either the strings 'abc' or 'ac' because the 'b' is considered optional.

    Similar to the dot metacharacter, if you want to match **?**, you need to add a slash **\** in front of this metacharacter.

- Lesson 9 All this whitespace

    The most common forms of whitespace with regular expressions are the**space**, the **tab(\t)**, the **new line(\n)** and the **carriage return(\r)**, and these special characters match each of their **respective** whitespaces.

    There is a whitespace **special character** **\s**, which can match **any of the specific whitespaces above**. And **\S** can match

- Lesson 10 Starting and ending

    We are supposed to write as specific regular expressions as possible to ensure that we don't get false sequences when matching texts. For example, we want to match the word "success" in a log file. We certainly don't want that pattern to match a line that says "Error: unsuccessful operation".

    One way to tighten our patterns is to define a pattern that describes both the **start and end of the line** using the special **^(hat)** and **$(dollar sign)** metacharacters.

    For example, **^success** matches a line that begins with 'success'. On the countary, **success$** matches a line that ends with 'success'

    In the example above, we can use the pattern **^success** to match only a line that begins with the word 'success'

    **Note** that this is different from the hat used **inside a set of brakcet[^...] for excluding characters**

- Lesson 11 Match groups

    Regular expressions allow us to not just match text but also to extract information for further processing. This is done by defining **gruops of characters** and **capturing** them **using the special parentheses(equals to bracket) **(** and **)** metacharacters. **Any subpattern inside a pair of parentheses will be captured as a gruop**

    Imagine for example that you had a command line tool to list all the images files you have in the cloud. You could then use a pattern such as **^(IMG\d+\.png)$ to capture and extract the full filename

- Lesson 12 Nested gruops

    When you are working with complex data, you can easily find yourself having to extract **multiple layers of information**, which can result in **nested gruops**

    Take the example from Lesson 11. If each of these image files had a sequential picture number in the filename, you could extract both the filename and the picture number using the same pattern by writing an expression like **^(IMG(\d+))\.png$**(using a **nested parenthesis** to capture the digits)

- Lesson 13 More gruop work

    Nothing to note

- Lesson 14 It's all conditional

    When using gruops, you can use the **|** to denote **different possible sets of characters**.

- Lesson 15 Other special characters

    There is a special metacharacter **\b** which matches the boundary between a word and a non-word character. It's most useful in capturing entire words. For example, use the pattern **\w+\b**

    One concept that we will not explore in great detail in these lessons is **back referencing**.Many regular expression engines allow you to reference your captured gruops by using **\0(usually the full matched text)**, **\1(gruop1)**, **\2(gruop2)**,etc.

    For example, when you o a search and replace using regular expressions to swap two numbers, you can search for **(\d+)-(\d+)** and replace it with "\2-\1" to put the second captured number first, and the first captured number second.

The contents mentioned above are all some fundmental materials of regular expressions. We turn to the usage of [regular expressions **in Python**.](https://regexone.com/references/python)

For more information about re in Python, visit [Python official documents for regular expressions](https://docs.python.org/3.6/library/re.html)

First of all, Python supports regular expressions through the standard python library **re**.

- Raw Python Strings

    When writing regular expression in Python, it is recommended that you use **raw strings** instead of **regular Python strings** because it's more concise and convenient.

    Raw strings begin with a special prefix **r** and singal Python not to **interpret backslashes and special metacharacters in the string**, allowing you to pass them through directly to the regular expression engine.

    This means that a pattern like **"\n\w"** will not be interpreted and can be written as **r"\n\w"** instead of **"\\n\\w"**, which is much easier to read.

    More details about **raw strings**. Here is a link about [raw strings.](https://docs.python.org/3.6/howto/regex.html#the-backslash-plague)

- Matching a string

    To test whether a regular expression matches a specific string, you can use ``re.search()``. This method either returns None if the pattern doesn't match, or a ``re.MatchObject`` with additional information about which part of the string the match was found.

    Method:

    ```python
    matchObject = re.search(pattern,input_str,flags=0)
    ```

    Example:

    ```python
    import re

    regex = r"([a-zA-Z]+) (\d+)"

    if re.search(regex, "June 24"):

        match = re.search(regex, "June 24")

        print("Match at index %s, %s" % (match.start(),match.end()))

        print("Full match: %s " % (match.group(0)))

        print("Month: %s " % (match.group(1)))

        print("Day: %s " % (match.group(2)))


    else:
        print("Match Failed")

    ```

- Capturing gruops

    Unlike the ``re.search()`` method, we can use ``re.findall()`` to perform a global search over the whole input string. If there are **capture gruops in the pattern**, then it will **return a list of all the captured data**, but otherwise, it will just **return a list of the matches themselves**, or an empty list if no matches are found.

    If you need additional context for each match, you can use ``re.finditer()`` which instead **returns an iterator of re.MatchObjects** to walk through.

    Method:

    ```python
    matchList = re.findall(pattern,input_str,flags=0)
    matchList = re.finditer(pattern,input_str,flags=0)
    ```

- Finding and replacing strings

    If you want to find and replace a part of a string using re, you can do this in Python with the ``re.sub()`` method.

    Method:

    ```python
    replacedString = re.sub(pattern, replacement_pattern,
                            input_str,count,flags=0)
    ```

    The optional ``count`` argument is the exact number of replacements to make in the input string. Obviously, if the value is less than or equal to zero, then every match in the string is replaced.

- **re** Flags

    In Python re methods above, you will notice that each of them also take an optional ``flags`` argument. Its default value is ``0``. But some ``flags`` can be useful.

    For example:

    ``re.IGNORECASE`` makes the pattern case insensitive so that it matches strings of **different capitalizations**

    ``re.MULTILINE`` is necessary if your input string has newline characters(\n), this flag allows the start and end metacharacter(^ and $) to match at the beginning and end of **each line** instead of the whole input string

    ``re.DOTALL`` allow the dot(**.**) metacharacter match all characters, including the newline character(\n)

- Compliling a pattern for performance

    In Python, creating a new regular expression pattern to match many strings can be slow, so it's recommended that you compile them if you need to be testing or extracting information from many input strings using the same expression. This method returns a ``re.RegexObjext``

    Method:

    ```python
    regexObject = re.compile(pattern,flags=0)
    ```

- 