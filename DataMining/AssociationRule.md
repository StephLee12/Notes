- [Chapter 3 Association Rule](#chapter-3-association-rule)
  - [频繁项集的产生](#频繁项集的产生)
    - [BF](#bf)
    - [Apriori](#apriori)
    - [频繁模式挖掘面临的挑战](#频繁模式挖掘面临的挑战)
    - [提高Apriori算法效率](#提高apriori算法效率)
  - [FP-Growth(Frequent-Pattern Growth)](#fp-growthfrequent-pattern-growth)
  - [规则产生](#规则产生)
  - [关联模式的评估](#关联模式的评估)

# Chapter 3 Association Rule

👉 定义

给定集合$\,T\,$,关联规则发现是**找出支持度$\,\geq min\_sup\,$并且置信度$\,\geq min\_conf\,$的所有规则**

关联规则是形如$\,X \rightarrow Y\,$的表达式($\,X和Y\,$是不相交的项集)

👉 相关概念

- 频繁模式——数据库中频繁出现的项集
- 项集(Itemset)——包含0个或多个项的集合
- 支持度计数($\,\sigma\,$)——包含特定项集的事务个数
- 支持度——包含特定项集的事务数/总事务数
- 频繁项集(Frequent Itemset)——满足**最小支持度阈值**$\,min\_sup\,$的所有项集

👉 关联规则的强度

- 支持度——确定项集的**频繁程度**

$$
    support(X \rightarrow Y) = P(X \bigcup Y)
$$

- 置信度——确定Y在包含X的事务中出现的频繁程度
  - 注意在置信度的计算中忽略了$Y$的作用

$$
    confidence(X \rightarrow Y) = P(Y | X) = \frac{support(X\bigcup Y)}{support(X)}
$$



👉 关联规则挖掘一般步骤

1. 频繁项集产生
2. 规则的产生(在频繁项集中提取所有高置信度的规则，这些规则称为强规则)

## 频繁项集的产生

### BF

👉 不考虑 时间复杂度太高 指数级

👉 降低产生频繁项集计算复杂度的方法

- 减少候选项集的数量——Apriori原理
- 减少比较的次数——使用高级的数据结构，或存储候选项集或压缩数据集，来减少比较次数

### Apriori

👉 理论基础

- 如果一个项集是频繁的，则它的**所有子集**一定是频繁的
- 如果一个项集是非频繁的，则它的**所有超集**也一定是非频繁的

👉 剪枝原则

如果一个项集不是频繁的，不产生它的超集

这种基于**支持度度量**修剪**指数搜索空间**的策略称为**基于支持度的剪枝**

👉 方法

长度为k的**频繁项集**产生长度为k+1的候选项集(**连接，剪枝**)，扫描DB测试候选项集

连接的算法

![apriori连接](Captures/apriori连接.PNG "apriori连接")

剪枝的算法

![apriori剪枝](Captures/apriori剪枝.PNG "apriori剪枝")

👉 算法步骤

![apriori](Captures/apriori.PNG "apriori")

### 频繁模式挖掘面临的挑战

- 事务数据库的多遍扫描，IO开销大
  - 改进——减少扫描次数
- 数量巨大的候选项集
  - 改进——压缩候选数量
- 候选支持度计数繁重的工作量
  - 便于候选计数

### 提高Apriori算法效率

- 散列项集计数
  - 压缩候选项集
    - 一个哈希桶中计数小于最小支持度阈值的项集不可能是频繁的
- 事务压缩
  - 删除不可能对寻找频繁项集有用的事务
    - 根据k项集若不是频繁，则其超集不为频繁项集，将超集打上标签或直接删除
- 划分
  - 分而治之
- 采样
  - 选取事务数据库的一个样本进行关联规则挖掘
  - 牺牲精度换取效率

## FP-Growth(Frequent-Pattern Growth)

👉 不同于Apriori先产生候选项集再产生频繁项集的方法，使用**FP树**数据结构组织数据，**直接从该结构中提取频繁项集**

👉 基本思想

- 将代表频繁项集的数据库压缩到FP树上
- 将FP树划分为一组条件数据库，挖掘每个条件数据库获取频繁项集

👉 构造FP树

- 支持度排序——扫描一次数据库，将获得的频繁1项集按照**支持度降序**排列，丢弃非频繁项
- 构建FP树——第二次扫描数据库 将每个事务都压缩到FP树上 ![FP树构造](Captures/FP树构造.PNG "FP树构造")**直到每个事务都映射到FP树的一条路径**![FP树构造完成](Captures/FP树构造完成.PNG "FP树构造完成")注意每一个频繁1项集都有一个对应的链表(总体是一个桶)，指向树中对应的位置，以便可以快速访问

👉 构建**条件模式基**

以每一个频繁1项集作为**后缀**，找出路径中以**该项为后缀**的**前缀路径**

![FP条件模式基](Captures/FP条件模式基.PNG "FP条件模式基")

感觉要是构造算法 这一步两层循环

- 外层循环遍历频繁1项集
- 内层循环遍历每一项的链表，要追溯到``null``根结点为止

条件模式基相当于一个桶

👉 构建**条件FP树**

将每一个条件模式基看成一个**子数据库**，这里要根据最小支持度阈值删除某些项

![FP树构造条件FP树](Captures/FP树构造条件FP树.PNG "FP树构造条件FP树")

在项I5时，由于I3不满足最小支持度阈值，所以删掉

在项I4时，I1也是同理被删掉

👉 在条件FP树上挖掘频繁项集

- 若条件FP树为单路径，则产生该路径下所有模式的组合![FP树单路径](Captures/FP树单路径.PNG "FP树单路径")
- 若条件FP树为多路径，则针对树的每一个频繁1项集，产生对应的**条件模式基**获取频繁模式，如此处在I3项前分别加上I2、I1项，以(I2、I3和I1、I3)为后缀，寻找它们的前缀路径，从而构建新的FP树 ![FP树多路径](Captures/FP树多路径.PNG "FP树多路径")

👉 算法步骤

![FP树算法](Captures/FP树算法.PNG "FP树算法")

## 规则产生

👉 将一个频繁项集$\,Y\,$划分为两个非空的子集$\,X\,$和$\,Y-X\,$,使得$\,X \rightarrow Y-X\,$满足置信度阈值$\,min\_conf\,$

👉 计算关联规则的置信度**不需要再次扫描数据库**，因为分割后的两个子集一定是频繁项集(一个频繁项集的子集一定是频繁的)，这两个集合的支持度都是已经计算得到的

## 关联模式的评估

👉 建立一组广泛接收的**评价**关联模式**质量**的**标准**是很重要的

- 通过统计论据建立
- 主观论据的建立

👉 现有关联规则的挖掘算法依赖**支持度和置信度**来去除没有意义的模式。但是可能会出现误导

![关联规则评估](Captures/关联规则评估.PNG "关联规则评估")

![关联规则评估1](Captures/关联规则评估1.PNG "关联规则评估1")

👆原因在于：置信度忽略了**规则后件(即👆的咖啡)中项集的支持度**

为了解决这个问题，提出了新的度量

- 提升度
  - 关联规则置信度与规则后件项集支持度的比值
- 兴趣因子
  - 二元变量的度量

![关联规则评估2](Captures/关联规则评估2.PNG "关联规则评估2")