- [栈(stack)和队列(queue)](#%e6%a0%88stack%e5%92%8c%e9%98%9f%e5%88%97queue)
  - [概述](#%e6%a6%82%e8%bf%b0)
  - [栈](#%e6%a0%88)
  - [队列](#%e9%98%9f%e5%88%97)
  - [迷宫求解和状态空间搜索](#%e8%bf%b7%e5%ae%ab%e6%b1%82%e8%a7%a3%e5%92%8c%e7%8a%b6%e6%80%81%e7%a9%ba%e9%97%b4%e6%90%9c%e7%b4%a2)
  - [栈和队列的补充](#%e6%a0%88%e5%92%8c%e9%98%9f%e5%88%97%e7%9a%84%e8%a1%a5%e5%85%85)
  - [其他](#%e5%85%b6%e4%bb%96)

# 栈(stack)和队列(queue)

在常用的数据结构中，有一批结构被称为**容器** 一个容器结构里总包含一组其它类型的数据对象，称为**元素**，容器支持对这些元素的操作。

例如线性表就是一类容器

下面介绍两种最常用的容器 **栈** **队列**

## 概述

栈和队列主要用于在计算过程中保存临时数据。

工作中产生的中间数据暂时不用或者用不完，就有必要将其存储起来。如果可能生成的**数据项数**在编程时就可以确定，那么可以设置几个变量作为临时存储。**但如果不能事先确定**，就必须采用更复杂的机制存储和管理，这样的存储机制称为**缓冲存储(即缓存)**

栈和队列就是使用最多的缓存结构，也是最简单的缓存结构，它们**只支持数据项的存储和访问**，不支持数据项之间的任何关系。

Attention！

- 栈是保证元素后进后出(Last In Firt Out, LIFO)的结构，简称LIFO结构
- 队列是保证元素先进先出(First In First Out, FIFO)的结构，简称FIFO结构
- 由于计算机存储器的特点，要实现栈和队列，最自然的技术就是用**元素存储的顺序**表示它们的时间顺序，即**用线性表**作为栈和队列的实现结构
- 可直接用``list``实现栈的功能，此外，Python标准库还提供了一种支持队列用途的机构``deque``

## 栈

- 概念

    栈的ADT

    ```python
    ADT Stack:
        Stack(self) #创建空栈
        is_empty(self) #判断栈是否为空
        push(self,elem) #将元素elem压入栈
        pop(self) #弹出(删除并返回)栈里最后压入的元素
        top(self) #取得栈里最后压入的元素，不删除
    ```

    线性表是栈一种最自然的实现方式，在表实现中，执行插入和删除操作的一端被称为**栈顶**，另一端称为**栈底**

    对于顺序表，后端插入和删除都是$\,O(1)\,$操作，应选用此端为栈顶

    对于链表，前端插入和删除都是$\,O(1)\,$操作，应选用此端为栈顶

- 栈的顺序表实现

    Python中的``list``可以直接作为栈来使用(假设``lst``是一个表)

    建立空栈对应创建一个空表``[]``，判断空栈对应检查是否是空表

    由于``list``采用动态顺序表，作为栈的表不会溢出

    压入元素操作应在表的尾端进行，对应``lst.append(x)``

    访问栈顶的操作用``lst[-1]``

    弹出操作在表的尾端进行，``lst.pop()``默认弹出表尾元素

    但是虽然采用``list``可以完全满足栈的需求，但是``list``提供了**很多栈原本不应该支持的操作，威胁栈的使用安全性**，因此要定义一个栈的类，但是在栈类中完全可以用``list``作为其实现基础，详见代码。

    ```python
    class StackUnderflow(ValueError):
        pass

    class SStack(): #基于顺序表技术实现的栈类

        def __init__(self): #用list对象 _elems存储栈中元素
            self._elems = [] #所有栈操作都映射到list操作

        def is_empty(self):
            return self._elems == []

        def top(self):
            if self._elems == []:
                raise StackUnderflow("in SStack.top()")

            return self._elems[-1]

        def push(self,elem):
            self._elems.append(elem)

        def pop(self):

            if self._elems == []:
                raise StackUnderflow("in SStack.pop()")

            return self._elems.pop()
    ```

- 栈的链接表实现

    采用链接表技术，应该用表头一端作为栈顶，表尾作为栈底。

    详见代码

    ```python
    class LNode:
          def __init__(self,elem,next_=None):
            self.elem = elem
            self.next = next_

    class LStack(): #基于链接表技术实现的栈类，基于单链表

        def __init__(self):
            self._top = None

        def is_empty(self):
            return self._top is None

        def top(self):
            if self._top is None:
                raise StackUnderflow("in LStack.top()")
            return self._top.elem

        def push(self,elem):
            self._top = LNode(elem,self._top)

        def pop(self):
            if self._top is None:
                raise StackUnderflow("in LStack.pop()")

            e = self._top.elem
            self._top = self._top.next

            return e
    ```

- 栈的应用
  - 括号匹配问题

    下面只考虑三种括号:圆括号、方括号和花括号。且每种括号都包括一个**开括号**和一个**闭括号**相互对应

    括号的匹配原则: 在扫描过程中，遇到的闭括号应该于此前**最近遇到且尚未获得匹配的开括号**配对。如果最近的未匹配开括号与当前闭括号不配对，或者找不到这样的开括号，就是匹配失败，说明这段正文里的括号不配对

    因为存在多种不同的括号对，每种括号都可能出现任意多次，还可能嵌套，为了检查是否匹配，扫描中必须保存遇到的开括号，由于不能确定数目，必须使用**缓存结构**，开括号的存储显然符合**LIFO**原则

    ```python
    def check_brackets(text):

        brackets = "()[]{}"
        open_brackets = "([{"
        bra_dict = {")":"(",
                    "]":"[",
                    "}":"{"} # 配对关系的字典

        def gen_brackets(text):
            # 括号生成器 每次调用返回text里下一括号及其位置
            i, text_len = 0 , len(text)
            while True:
                while i < text_len and text[i] not in brackets:
                    i = i + 1
                if i >= text_len:
                    return
                yield text[i],i
                i = i + 1

        st = SStack() #创建栈

        for pr, i in gen_brackets(text): #对text里的各括号和位置迭代
            if pr in open_brackets: #开括号压入栈中
                st.push(pr)
            elif st.pop() != bra_dict[pr]:
                print("Unmatching is found at",i,"for",pr)
                return False
            else:
                continue

        print("All brackets are correctly matched")
        return True
    ```

    这里的局部函数``gen_brackets``，是一个扫描正文的生成器函数，它逐个返回一个个括号及其串中的位置

    生成器是Python中一种用函数形式定义的迭代器，其中的``yield``语句产生结果。主函数代码里的``for``循环里用两个变量接收生成器产生的值

    使用生成器占用的内存更少

  - 表达式的表示、计算和变换

    数学表达式中最重要的构造符号是**一组二元运算符**。

    将二元运算符卸载两个运算对象中间，这种写法称为**中缀表示**形式，按照中缀表示写出的表达式称为**中缀表达式**

    虽然中缀表达式对于人脑来说很好理解，但不利于计算机的处理。因此提出了**前缀表达式(也称波兰表达式)** 和 **后缀表达式(逆波兰表达式)**，这两种表达形式**都不需要引进括号，也不需要任何有关优先级或结合性的规定**

    下面是后缀表达式的大体思路：

    ①:从左至右扫描表达式

    ②:遇到数字时，将数字压入栈中，遇到运算符时，**弹出栈顶的两个数**，用运算符对它们做相应的运算(**次顶元素 op 栈顶元素**)，并将结果压入栈中

    ③:重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果 **注意，如果处理运算符时栈中元素不足两个，操作就应该失败，所以需要检查栈的深度，在栈类中增添新的方法**

    i.e. 前缀表达式的步骤与后缀表达式相反，详见[link](https://www.cnblogs.com/zzliu/p/10801113.html)

    详见代码

    下面是中缀表达式到后缀表达式的转换

    ![示例图](snapshots\中缀后缀表达式.PNG "中缀和后缀表达式")

    ①:扫描过程中如果遇到运算对象，**将其直接送出，作为后缀表达式的一个项**

    ②:而对于运算符，要处理好中缀表达式中的**优先级** 以及**结合性** 的问题

    对于上述的第二个问题：

    ①(先不考虑括号)扫描遇到运算符$\,o\,$时，将其与前面未处理的运算符$\,o^{'}\,$比较，如果$\,o\,$的优先级不高于$\,o^{'}\,$，则做$\,o^{'}\,$的计算(即输出$\,o^{'}\,$)，而后记录$\,o\,$(无论做没做$\,o^{'}\,$)的计算，在这个过程中，总要拿当前运算符和前一个未输出的运算符比较，而且运算符的个数未知，所以应该用一个**栈**来保存尚未处理的运算符

    ②对于括号，左括号标明了**一个应该优先计算的子表达式的起点**，右括号表明**该子表达式的终点**，**在满足①的前提下，遇到右括号时需要逐个弹出栈中的运算符(排在后面的必定具有更高的优先级)，直到遇到左括号时也将其弹出**

    代码如下:

    ```python
    priority = {"(":1,
            "+":3,
            "-":3,
            "*":5,
            "/":5} #字典 代表优先级 开括号优先级最低，保证其他的运算符都不会将其弹出

    infix_operators = "+-*/()"

    def trans_infix_suffix(line):
        st = SStack()
        suf_exp = []

        for x in generator(line): #tokens是一个生成器
            if x not in infix_operators:# 不是运算对象 直接送入suf_exp
                suf_exp.append(x)
            elif st.is_empty() or x == '(': #左括号进栈
                st.push(x)
            elif x == ')': #遇到右括号时 依次弹出运算符
                while ((not st.is_empty()) and (st.top() != '(')):
                    suf_exp.append(st.pop())
                if st.is_empty():
                    raise SyntaxError("Missing '(' ")
                st.pop() #将左括号也弹出
            else: #markdown中的第一种情况 比较相邻两个运算符的优先级
                while ((not st.is_empty()) and (priority[st.top()] >= priority[x])):
                    suf_exp.append(st.pop())
                st.push(x)

            while not st.is_empty(): #送出栈里剩下的运算符
                if st.top() == '(':
                    raise SyntaxError("Extra '(' ")

                suf_exp.append(st.pop())

            return suf_exp

    def generator(line):
        #生成器函数 逐一生成line中的每一个项 
        #项是浮点数或是运算符，但是此函数不能处理一元运算符，也不能处理带符号的浮点数
        i , len = 0 , len(line)

        while i < len:
            while line[i].isspace(): #检测line[i]是否是空格
                i = i + 1

            if i >= len:
                break

            if line[i] in infix_operators: #如果line[i]是运算符
                yield line[i]
                i = i + 1
                continue

            j = i + 1

            while ((j < len) and (not linep[j].isspace() ) and (line[j] not in infix_operators)):
                if (line[j] == 'e' or line [j] == 'E') and (j + 1< len and line[j+1] == '-'):
                    j = j + 1

                j = j + 1

            yield line[i:j]
            i = j

    def test_trans_infix_suffix():
        while True:
            try:
                line = input("Infix Expression: ")
                if line == "end":
                    return
                print(trans_infix_suffix(line))
                print("Suffix Expression's Value: ", suf_exp_getValue(trans_infix_suffix(line)))
            except Exception as ex:
                print("Error: ", type(ex),ex.args)
    ```

    该计算器处理的功能有限！！！

    为了更好的处理算数表达式，首先需要**定义“项(计算时要用项表)”的形式和表达式的结构，然后**根据它们实现将字符串分解为项的函数(生成器函数)**。这一过程称为**词法分析或语法分析**，详细的思想是“编译原理”课程的内容

    关于中缀表达式的求值，可以用上述的方法，先转换为后缀表达式，再求值。

    但是也可以直接计算中缀表达式，这样**扫描项表时遇到运算对象不能输出，而应该临时保存起来，根据后缀表达式的运算规则，每当需要执行一个运算时，运算对象是前面遇到的运算对象，或者是最近计算的结构，在后缀表达式中用一个栈来保存这些数据**，同样的，此处也可以引进一个数据栈。

    所以直接计算中缀表达式的步骤如下:

    说白了就是多引用了一个栈充当中缀到后缀的转换过程

    ① 扫描中遇到运算对象将其压入数据栈(后缀表达式``getValue``函数的操作)

    ② 遇到运算符或者括号时，按照前面转换算法中的方式，分几种情况处理。若是**左括号**，压入运算符栈；若是**右括号**，弹出运算符完成计算，直到弹出对应的左括号。若是**其他运算符**，按照优先级处理，即比较相邻两个。

    ③ 确定了计算的一个运算符时,操作数就是数据栈顶的两个项，完成计算后的数据要压入栈中

    ④ 整个表达式处理完后，逐项弹出运算符栈剩下的运算符 按照③完成计算

  - 栈的递归
    - 递归的定义: 在一个定义中引用了被定义的对象本身。如一个函数在函数体内引用了本函数。 在一种数据结构里某个或某几个部分具有与整体相同的结构，也称为一种**递归结构** 例如单链表就是一种递归结构，这样的表或者为空，不为空时去掉表头结点，剩下的结点具有和原来相同的结构。

        在递归结构中，**递归的部分必须比原来的整体简单，这样才有可能达到某个终结点(称为递归的出口)**。例如，单链表中的空链接``None``就是递归的终点

    - 阶乘函数的递归计算

        $$
            fact(n) =
            \begin{cases}
            1, & n = 0 \\
            n*fact(n-1), & n\neq0 \\
            \end{cases}
        $$

        相应的代码:

        ```python
        def fact(n):
            if n == 0:
                return 1
            else:
                return n * fact(n-1)
        ```

        显然，要想得到``fact(6)``,必须先算出``fact(5)``,以此类推。每一次计算都要记录``n``的取值，因此**需要这样记录的量与递归的层数成线性关系**，一般来说没有明确的上限。

        而且，在记录的一系列数据中，较后保存的被先使用，属于LIFO结构，显然需要一个**栈**来支持递归函数的运行，这个栈称为**程序运行栈**

        下图反映了计算阶乘时的数据流

        ![阶乘计算数据流](snapshots\阶乘计算数据流.PNG "snapshots\阶乘计算数据流.PNG")

        下图是程序运行栈的变化图

        ![阶乘程序运行栈](snapshots\阶乘程序运行栈.PNG "阶乘程序运行栈")

        关于函数调用的前后的操作如下:

        函数调用前:

        ① 为被调用函数的局部变量和形参分配存储区(称为函数帧)

        ② 将所有实参和函数的返回地址存入函数帧(传值)

        ③ 将控制转到被调函数入口

        函数调用后:

        ① 将被调用函数的计算结果存入指定位置

        ② 释放被调函数的函数帧

        ③ 按被调前存入的返回地址将控制转回调用函数

    - 非递归

        递归的每次调用执行的都是这段函数体的代码，程序运行时在内部创建一个运行栈来保存每次调用的局部信息。

        完全可以在程序编写时创建一个栈，可以完成同样的计算

        注意，将递归问题转化为非递归问题，更合适的方法是先分析算法的具体情况，也可能存在不需要栈的情况。

        ```python
        def non_recursive_fact(n):
            res = 1
            st = SStack()
            while n > 0:
                st.push(n)
                n = n -1
            while not st.is_empty():
                res = res * st.pop()
            return res
        ```

    - 递归的应用:背包问题

        问题描述:一个背包中可以放入重量$\,weight\,$的物品，现有$\,n\,,$件物品的集合$\,S\,$,其中物品的重量分别为$\,w_0,w_1,\cdots,w_{n-1}\,$。问能否从中选出**若干件**物品，其重量之后正好等于$\,weight\,$，如果存在则该问题有解，否则无解。

        该问题可以有很多变形，如**可以要求一个存在解时给出一个解**，**也可以改变问题的条件，如物品不是$\,n\,,$而是$\,n\,,$种，每种都有任意多件可用etc。

        分析如下:

        设$\,weight\geq0\,$,$\,n\,$。用$\,knap(weight,n)\,$表示$\,n\,$件物品相对于总重量$\,weight\,$的背包问题。在考虑它是否有解时，通过考虑一件物品**选或不选**，可以把原问题划分为两种:

        ① 如果不选最后一件物品(重量为$\,w_{n-1}\,$)，那么$\,knap(weight,n-1)\,$的解也就是$\,knap(weight,n)\,$的解，找到前者的解则找到了后者的解

        ② 如果选择最后一件物品，那么如果$\,knap(weight-w_{n-1},n-1)\,$有解，则该问题有解

        注意，本问题中，每种重量的物品有且仅有一件，**用或者不考虑**

        通过以上分析，该问题具有递归的性质:对$\,n\,$件物品的背包问题，可以归结为两个$\,n-1\,$物品的背包问题。一个针对同样重量但物品种类减一;另一个则是减少了重量，物品种类也减一

        由此递归，最后到递归的出口有以下几种情况:

        ① 重量$\,weight\,$已经为$\,0\,$，说明该问题有解

        ② 重量$\,weight\,$小于$\,0\,$，说明按照此种分配方式无解

        ③ 重量大于$\,0\,$但物品种类为0，说明按照此种分配方式无解

## 队列

- 基本概念

    队列是FIFO结构，可以用线性表的方式存储

    ```python
    ADT Queue:
        Queue(self) #创建空队列
        is_empty(self) #判断队列是否为空
        enqueue(self,elem) #元素elem入队
        dequeue(self) #弹出队列中最早进入的元素，称为出队
        peek(self) #查看队列里最早进入的元素
    ```

- 队列的链接表实现

    由于是FIFO结构，需要在表的两端进行操作，普通的单链表只支持首端的高效操作，在另一端操作需要$\,O(n)\,$时间，可以采用带有表尾指针的单链表，支持$\,O(1)\,$时间的尾端插入操作

- 队列的顺序表实现

    由于是FIFO结构，出队即弹出表头，表的其他元素都要前移，花费$\,O(n)\,$。若出队后表中的元素不前移，而是记住新表头的位置，虽然时间花费减小了，但是表前端留下了越来越多的空位。

    因此可采用循环顺序表(约瑟夫环)，将顺序表视为**环型结构**，如下图所示

    ![队列环型顺序表](snapshots\队列环型顺序表.PNG "队列环型顺序表")

    ① 队头变量``q.head``记录当前队列里第一个元素的位置(图中是位置4) 队尾变量``q.rear``记录当前队列里最后元素之后的第一个空位(图中是位置1)，``q.elems``始终指向表元素区的开始，即位置0

    ② 队列元素保存在顺序表的一段连续单元里，``Python``的写法是``[q.head:q.rear]``(注意区间是左闭右开)

    ③ 出队和入队分别更新``q.head``和``q.rear``

    ```python
    q.head = (q.head + 1) % q.len
    q.rear = (q.rear + 1) % q.len
    ```

    注意此处的**求模运算**

    ④ 判断队列为空的条件是``q.head==q.rear``，但是在上图中进行几次入队操作，可能出现下图的状态，在加入一个元素顺序表就满了，但是此时也会出现``q.head==q.rear``的情况，导致无法区分

    ![队列环型顺序表状态判断](snapshots\队列环型顺序表2.PNG "队列环型顺序表状态判断")

    可以将队满的条件设置为``(q.rear+1) % q.len == q.head``，但这样处理，顺序表中会留下一个不用的空位

- 队列的list实现

    考虑定义一个可以**自动扩充存储的队列类**，这里很难利用``list``的自动存储扩充机制，[list自动存储机制见对应的markdown](线性表.md)。

    第一个原因: 队列元素的存储方式与``list``元素默认存储方式不一致，``list``元素总在存储区的最前面一段，而队列的元素可能是表里的任意一段，如果``list``自动扩充，队列元素可能会失控

    第二个原因: ``list``没提供检查元素存储区容量的机制，队列操作中无法判断系统何时扩容

    基本的设计如下:

    ① 在``SQueue``对象里用一个``list``类型的成分``_elems``存放队列元素

    ② 与图5.8不同，这里考虑用两个属性``_head``和``_num``分别记录队列首元素所在的位置下标和表中元素的个数

    ③ 需要检查当前的表是否已满，记录当前表的长度``_len``

  - 数据不变式

    要完成的队列是一个较复杂的结构，队列的状态涉及队列对象的四个属性``_elems _head _num _len``,队列的变动操作会改变一些对象属性的取值，若操作的实现相互不协调，会破坏队列对象的状态。

    因此在实现数据结构的操作时，最基本的问题是**这些操作需要维护对象属性之间的正确关系**，这样的关系称为这种数据结构的**数据不变式**

    队列的数据不变式如下:

    ① ``_elems``属性引用队列的元素存储区，是一个``list``对象，``_len``属性记录存储区的有效容量(Python中无法获知该list对象的实际大小)

    ② ``_head``是队列中的首元素(最早存入的元素)的下标，``_num``始终记录着队列中元素的个数

    ③ 队列中的元素总保存在``_elems``里从``_head``开始的连续位置，新入队的元素存入由``_head + _num``算出的位置，**但如果元素要存入下标``_len``的位置，改为在下标0位置存入该元素** 因为在``_head``的前面``_elem``还有空位 这样的处理类似于循环顺序表

    ④ 在``_num == _len``的情况下出现入队操作，扩大存储区

    具体实现见代码

    ```python
    class QueueUnderflow(ValueError):
        pass

    class SQueue():
        def __init__(self,init_len=8):
            self._len = init_len #存储区长度
            self._elems = [0] * init_len #元素存储 list对象
            self._head = 0     #队头
            self._num = 0  #队中元素个数

        def is_empty(self):
            return self._num == 0

        def peek(self):
            if self._num == 0:
                raise QueueUnderflow("in peek")

            return self._elems[self._head]

        def dequeue(self):
            if self._num == 0:
                raise QueueUnderflow("in dequeue") 

            e =  self._elems[self._head]
            self._head = (self._head + 1) % self._len
            self._num = self._num -1 
            return e

        def enqueue(self,elem):
            if self._num == self._len:
                self.__extend()

            self._elems[(self._head + self._num) % self._len ] = elem
            self._num  = self._num  + 1

        def __extend(self):
            old_len = self._len
            self._len = self._len * 2
            new_elems = [0] * self._len

            for i in range(old_len):
                new_elems[i] = self._elems[(self._head + i) % old_len]

            self._elems, self._head = new_elems, 0
    ```

- 队列的应用

    如文件打印等排队问题

## 迷宫求解和状态空间搜索

- 迷宫求解的分析

    迷宫问题，说白了就是找路径的问题

    下图是一个简单的迷宫 ![简单迷宫](snapshots\简单迷宫.PNG "简单迷宫")

    空白格代表可以通行，带阴影的格子表示障碍。

    这种迷宫可以直接映射到二维的0/1矩阵，可以将空白格用0表示，障碍用1表示

    由于在寻找路径的时候存在分岔路，但求解此问题只需找到一条路径即可，但选择一条分叉继续搜索不一定可以得到一个可行解，因此需要保存分支信息。

    搜索可以分为两种方式:

    ① 如果搜索当前位置还没找到出口，可以继续向前走，直到无路可走再考虑后退，换一条没走过的路继续

    ② 每一步都从最早记录的分叉口向前进，找到下一个可达位置并记录它

    考虑栈和队列

    若使用栈，搜索过程是每步选择一种可能方向一直向前，直到无法前进才退回此前的**最后选择点**，换路径继续该过程。这种方法，实际上是**尽可能利用已经走过的路**，只有不得已时才后退到最近分支位置并继续沿另一条路搜索

    若使用队列，则是从最早遇到的搜索点不断拓展

    下面先考虑用栈来解决

    首先要将迷宫表示成二维矩阵，可以用以``list``为元素的``list``

    要注意:**搜索过程可能在局部路径上兜圈**，因此必须采取某种方法记录已探查过的位置，在继续搜索的过程中，需要不断检查，保证不重复搜索同一位置。

    记录已探查位置的方式大概有两种:

    ① 采用某种专门的结构记录

    ② 把已经检查过的信息直接标记在迷宫上

    取后者，因为检查起来更方便。像前面所说，可通行的位置为0，障碍为1，可以将检查过的位置标记为2

    还需要一种确定**当前位置可行方向**的技术，在到达某个分叉位置时，搜索过程需要选一个方向前进，如果再次退回这里，就要改走另一方向，直至所有方向都已探查为止，如果还没有找到出口，就要退后一步

    某一位置的相邻元素的下标计算如下图所示 ![相邻元素下标计算](snapshots\相邻元素下标计算.PNG "相邻元素下标计算")

- 迷宫问题——递归求解

    上文所述，回退一步后，取一个可行的相邻位置用同样方式探查，如果可以找到通往出口的路径，那么从当前位置到出口的路径就找到了

    算法的步骤如下:

    ① 标记当前位置为2

    ② 检查当前位置是否为出口，如果是，则成功

    ③ 逐个检查当前位置的四邻是否可以到达出口(递归调用自身)

    ④ 如果对四邻的探索都失败，报告失败

    代码如下:

    ```python
    dirs = [(0,1),(1,0),(0,-1),(-1,0)]

    def mark(maze,pos): #标记搜索过的位置为2
        maze[pos[0]][pos[1]] == 2

    def passable(maze,pos): #判断位置pos是否可以通行
        return maze[pos[0]][pos[1]] == 0

    def find_path(maze,pos,end):
        mark(maze,pos)

        if pos == end:
            print(pos, end="")
            return True

        for i in range(4):
            next_pos = pos[0] + dirs[i][0], pos[1] + dirs[i][1]

            if passable(maze,next_pos):
                if find_path(maze,next_pos,end):
                    print(pos,end="")
                    return True

        return True
    ```

- 迷宫问题——栈和回溯法——分析

    回溯法的基本操作和分析的一样，可以认为有两个操作:前进和后退

    **前进**:

    条件:当前位置存在尚未探查的四邻位置

    操作: 选定下一个位置并向前探查。如果还存在其他可能未探查的分支，就记录相关信息

    若找到出口，则成功结束

    **后退(回溯)**:

    条件: 遇到死路，不存在尚未探查的四邻位置

    操作: 退回最近记录的那个分支点，检查那里是否还存在未探查分支，如果有，就取一个分支作为当前位置继续前进，如果没有，将其删除并继续回溯

    当穷尽所有可能时，求解失败

    显然这里分支信息的记录需要用到LIFO结构，使用栈

    **回溯法是一种重要的算法设计模式**，通常用一个栈作为辅助结构，保存工作中发现的回溯点。

    回溯法的典型实现方法如下:

    ① 首先把出发点放入栈中

    ② 在栈不空的条件下，反复做下面几个操作(栈空时以失败结束)

    弹出一项以前保存的信息(作为当前点)

    检查从这里出发前进的可能性(找下一个探查点)

    如果可以向前(存在下一个可行位置):把从当前点出发的其他可能存入栈；把下一个探查点也入栈

    注意:

    ① 由于已将下一探查点入栈，下次迭代自然会将其取出使用

    ② 如果在当前点已经不存在前进的可能，转到下一次迭代，弹出更早保存的探查点(即进一步回溯)

    上述是遇到分支结点时处理方法，还有一个问题:搜索过程中把哪些位置入栈？可以将从出口到当前位置**途径的所有位置入栈**；也可以途径每个位置时，先检查此处的情况，只在栈里保存还存在其他未探查方向的位置

    使用第二种方法存在一个问题: 若前面讲一个**存在未探查方向的位置压入栈中**，后来回溯到这里，该位置可能不再存在未探查方向，因为原有未探查方向在此期间已经检查过了

    此外，为了在算法的最后输出找到路径，也需要知道路径上所有的位置

    因此选择第一种方式，将途径位置都压入栈中

- 迷宫问题——栈和回溯法——求解

    伪代码如下:

    ```python
    入口start相关信息(位置和尚未探索方向)入栈
    while 栈非空:
        弹出栈顶元素作为当前位置探索
        while 当前位置存在未探查方向:
            求出下一探查位置nextp
            if nextp是出口:
                打印路径 结束
            if nextp尚未探查:
                将当前位置(表明探查方向)入栈
                标记下一位置(序对的第二个元素为0)
                下一位置入栈 退出内层循环
    ```

    ```python
    def maze_st(maze,start,end):
        if start == end:
            print(start)
            return

        st = SStack()
        mark(maze,start)
        st.push((start,0))  #入口和方向0的序对入栈

        while not st.is_empty():
            pos, nxt = st.pop() #取栈顶及其探查方向 在下面探明方向之后还要压入栈中

            for i in range(nxt,4): #依次检查未探查方向
                nextp = (pos[0] + dirs[i][0],
                            pos[1] + dirs[i][1]) #算出下一位置

                if nextp == end:
                    print_path(end,pos,st) #print_path打印路径
                    return

                if passable(maze,nextp):
                    st.push((pos, i + 1))
                    mark(maze,nextp)
                    st.push((nextp,0))
                    break

        print("No Path Found!")

    def print_path(end,pos,st):
        print(end, ",", pos,",",end='')
        while not st.is_empty():
            pos , nxt = st.pop()
            print(pos,",",end='')

        print(" ")

    ```

    存入栈的的序对``(pos,nxt)``，其中分支点的位置``pos``用二维序对表示，``nxt``是整数，表示回溯到该位置时下一个探索的方向，所以有``st.push((pos,i + 1))``，4个方向分别编码``0,1,2,3``，对应表``dirs``的下标

    算法中发现一个新位置后，总是先标记它，然后再将其压入栈，保证了栈里保存的都是做过标记的位置，也保证了任何位置不会被压入栈两次。

    在这个栈里，一个栈元素的下一个元素总是路径上的前一个位置，保证了栈里的元素构成了一条路径

- 状态空间搜索

    迷宫问题是**状态空间搜索问题**的代表，基本特征如下:

    ① 存在一个状态集合 如迷宫问题中所有可能位置

    ② 有一个初始状态，一个或多个结束状态 如迷宫中入口为起始状态，出口为结束状态

    ③ 每个状态，都有与其相邻的一组状态(一步可达) 例如迷宫中每个位置(普遍意义上 不钻牛角尖 考虑特殊位置)都有四个相邻位置

    ④ 有一个判断函数 判断某一状态是否可行 例如迷宫中的函数``passable``

    这类问题即被称为**状态空间搜索或路径搜索**

- 迷宫问题——队列——求解

    前面的迷宫算法用到了栈，栈是LIFO结构，意味着**总是从最后遇到的状态出发考虑继续向前探索**，实际表现是**尽可能向前检查，尽可能向远处探索**，只有再后来的状态无法前进时，才考虑退回前面最近保存的状态，换一种可能性继续搜索。**后退并考虑其他可能性的动作就是回溯**

    而对于队列是FIFO结构，意味着先考虑距离近的状态，从这些状态向外扩展，实际上是**从各种可能性“齐头并进”式搜索**，这种搜索没有回溯，只是逐步扩张的过程

    求解基于用栈求解的设计

    伪代码如下:

    ```python
    将start标记
    start入队
    while 队列里还有未充分探查的位置:
        取出一个位置pos
        检查pos的相邻位置
            遇到end 结束
            尚未探查的都标记后入队
    队列空，搜索失败
    ```

    ```python
    def maze_que(maze,start,end):
        if start == end:
            print("Start Point is the end")
            return

        qu = SQueue()
        mark(maze,start)
        qu.enqueue(start)

        while not qu.is_empty():
            pos = qu.dequeue()

            for i in range(4):
                nextp = (pos[0] + dirs[i][0] ,
                            pos[1] + dirs[i][1])

                if passable(maze,nextp):
                    if nextp == end:
                        print("Problem Solved")
                        return

                    mark(maze, nextp)
                    qu.enqueue(nextp)

        print("No Solution")
    ```

    但上述代码没有解决将路径打印出来的问题。因为队列与栈不同，**队列里保存的位置及其顺序与路径无关**

- 迷宫问题的总结

    下图是使用栈和队列的区别，其中标交叉符号的是已经检查过的，圆圈表示当时栈里记录的位置。从图中可以印证上面所说，队列无法保存路径

    ![栈和队列的迷宫](snapshots\栈和队列的迷宫.PNG "栈和队列的迷宫")

    可以看出，基于栈的搜索可能进入一个局部区域，只有穷尽了该区域的状态才会退出来。任何时候栈里保存的位置总是从入口开始的一条路径

    基于队列的搜索，已经检查的位置以及连成一片，没有遗漏，是一种放射状的(即“扫荡”)，队列里的位置位于区域的前沿，它们构成已检查区域与未探索区域之间的分界。只有检查完所有与入口同样距离的位置之后才能继续前进

    把基于栈的搜索称为**深度优先搜索(DFS)** 基于队列的搜索称为**宽度优先搜索(WFS)**

    下面对DFS和WFS进行比较

    ① 假设搜索问题有解，能否保证找到解

    对于DFS，如果一个**不包含解的子区域很大**，DFS就会浪费很多时间。如果存在包含解的子区域很大，即使其他地方有解，DFS可能永远找不到解。WFS是一种扫荡的方式，只要存在到达解的有穷长路径，这种搜索过程一定能找到解，而且最先找到的一定是最短路径

    ② 搜索所有可能的解和最优解

    DFS在找到一个解之后继续回溯，有可能找到下一个解，遍历完整个状态空间就能找到所有的解，只有会找到所有的解才能从中选出最优解

    WFS找到一个解之后还可能找到其他解，但是到其他解的路径会越来越长，第一个解就是最优解

## 栈和队列的补充

- 双端队列

    双端队列deque，它允许在两端插入和删除元素，可以用双链表来实现

    Python中的``collections``包中定义一种``deque``类型

## 其他

1. 为什么链表可以实现统一的$\,O(1)\,$时间操作，还要考虑顺序实现

    目前各种计算机都采用分级缓存，填补CPU和主存之间的速度差

    所以如果连续进行的一批内存访问是局部的，硬件可以把这批内存复制到高速缓存，操作速度会快很多，因此考虑提高程序效率的一种方法就是尽可能使计算机内存的使用局部化。而顺序表就是局部化的一个典型代表

2. Python中的还有其他的效率更高的顺序表结构

    如内置的``bytes``和``bytearray``，库中的``bytearray``，它们可以看作受限的``list``，只能存储特定的类型对象，但是效率较高。
