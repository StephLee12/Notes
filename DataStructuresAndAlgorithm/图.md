- [图](#%e5%9b%be)
  - [概念 性质etc](#%e6%a6%82%e5%bf%b5-%e6%80%a7%e8%b4%a8etc)
    - [定义](#%e5%ae%9a%e4%b9%89)
    - [分类](#%e5%88%86%e7%b1%bb)
    - [性质](#%e6%80%a7%e8%b4%a8)
      - [完全图](#%e5%ae%8c%e5%85%a8%e5%9b%be)
      - [度(顶点的度)](#%e5%ba%a6%e9%a1%b6%e7%82%b9%e7%9a%84%e5%ba%a6)
      - [路径](#%e8%b7%af%e5%be%84)
      - [连通图](#%e8%bf%9e%e9%80%9a%e5%9b%be)
    - [一些概念](#%e4%b8%80%e4%ba%9b%e6%a6%82%e5%bf%b5)
      - [子图、连通子图](#%e5%ad%90%e5%9b%be%e8%bf%9e%e9%80%9a%e5%ad%90%e5%9b%be)
      - [带权图和网络](#%e5%b8%a6%e6%9d%83%e5%9b%be%e5%92%8c%e7%bd%91%e7%bb%9c)
    - [图的表示](#%e5%9b%be%e7%9a%84%e8%a1%a8%e7%a4%ba)
      - [邻接矩阵](#%e9%82%bb%e6%8e%a5%e7%9f%a9%e9%98%b5)
      - [邻接表](#%e9%82%bb%e6%8e%a5%e8%a1%a8)
  - [图的实现](#%e5%9b%be%e7%9a%84%e5%ae%9e%e7%8e%b0)
    - [邻接矩阵实现](#%e9%82%bb%e6%8e%a5%e7%9f%a9%e9%98%b5%e5%ae%9e%e7%8e%b0)
    - [邻接表实现](#%e9%82%bb%e6%8e%a5%e8%a1%a8%e5%ae%9e%e7%8e%b0)
  - [图算法](#%e5%9b%be%e7%ae%97%e6%b3%95)
    - [图的遍历](#%e5%9b%be%e7%9a%84%e9%81%8d%e5%8e%86)
      - [会遇到的问题](#%e4%bc%9a%e9%81%87%e5%88%b0%e7%9a%84%e9%97%ae%e9%a2%98)
      - [DFS](#dfs)
      - [BFS](#bfs)
      - [生成树](#%e7%94%9f%e6%88%90%e6%a0%91)
    - [最小生成树(Minimum Spanning Tree, MST)](#%e6%9c%80%e5%b0%8f%e7%94%9f%e6%88%90%e6%a0%91minimum-spanning-tree-mst)
      - [Kruskal算法](#kruskal%e7%ae%97%e6%b3%95)
      - [Prim算法](#prim%e7%ae%97%e6%b3%95)
    - [最短路径](#%e6%9c%80%e7%9f%ad%e8%b7%af%e5%be%84)
      - [Dijkstra算法(求解单源点最短路)](#dijkstra%e7%ae%97%e6%b3%95%e6%b1%82%e8%a7%a3%e5%8d%95%e6%ba%90%e7%82%b9%e6%9c%80%e7%9f%ad%e8%b7%af)
      - [Floyd算法(求解多源点最短路)](#floyd%e7%ae%97%e6%b3%95%e6%b1%82%e8%a7%a3%e5%a4%9a%e6%ba%90%e7%82%b9%e6%9c%80%e7%9f%ad%e8%b7%af)
    - [AOV/AOE网(关于有向图)](#aovaoe%e7%bd%91%e5%85%b3%e4%ba%8e%e6%9c%89%e5%90%91%e5%9b%be)
      - [AOV网](#aov%e7%bd%91)
      - [AOV网的拓扑排序](#aov%e7%bd%91%e7%9a%84%e6%8b%93%e6%89%91%e6%8e%92%e5%ba%8f)
      - [AOE(activity on edge network)网](#aoeactivity-on-edge-network%e7%bd%91)

# 图

## 概念 性质etc

### 定义

二元组$\,G=(V,E)\,$

$\,V(Vertex)\,$是非空有穷的**顶点**集合

$\,E(Edge)\,$是**边**的集合

**Attention**: $\,\mid E \mid \leq \mid V \mid^2\,$,即$\,\mid E \mid = O(\mid V \mid^2)\,$

边的表示：$\,<v_i,v_j>\,$表示从顶点$\,v_i\,$到顶点$\,v_j\,$的边，称顶点$\,v_i\,$是这条边的**始点**，顶点$\,v_j\,$是这条边的**终点**，称顶点$\,v_j\,$是$\,v_i\,$的**邻接顶点**

### 分类

有向图和无向图

有向图的边有方向，是顶点的有序对；无向图的边没有方向，是顶点的无序对

### 性质

#### 完全图

定义：任意两个顶点之间都有边的图称为**完全图**

$\,n\,$个顶点的无向完全图有$\,n\times (n-1) /2\,$条边

$\,n\,$个顶点的有向完全图有$\,n\times (n-1)\,$条边

#### 度(顶点的度)

一个顶点的度就是与它**邻接**的边的条数

对于有向图，顶点的度还分为**入度**和**出度**，分别表示以该顶点为终点或始点的边的条数

顶点数、边数、顶点度数有以下关系
$$
    e = \frac{1}{2} \sum_{i} D(v_i)
$$
其中$\,D(v_i)\,$表示顶点$\,v_i\,$的度数，$\,e\,$表示边数

#### 路径

- 路径的**长度**就是该路径上边的条数
- **回路**是指起点和终点相同的路径
- 如果一个回路除起点和终点外的其他顶点均不相同，称为**简单回路**
- 内部不包含回路的路径，称为**简单路径**。即除起点和终点可能相同外，其他顶点均不同
- 如果在有向图$\,G\,$中存在一个顶点，从该顶点到图中其他顶点都有路径，则称$\,G\,$是**有根图**，该顶点是$\,G\,$的一个根

#### 连通图

**连通**定义：如果无向图中存在从$\,v_i\,$到$\,v_j\,$的**路径**(由于是无向图，自然也是$\,v_j\,$到$\,v_i\,$的路径)，则说$\,v_i\,$与$\,v_j\,$之间连通(即两个顶点连通不一定两个顶点之间有边)。对于有向图的连通性可以不是双向的。

**连通无向图**定义：无向图任意两个顶点之间都连通

**强连通有向图**定义：有向图的任意两个顶点**互相连通**

显然，完全无向图都是连通图，完全有向图都是强连通图，但反之不成立。

**最小连通图**定义：是连通图，但去掉图中任一条边之后不再是连通图

包含$\,n\,$个顶点的最小连通无向图恰有$\,n-1\,$条边

**最小有根图**定义：是有根图，去掉任一边后不再是有根图

包含$\,n\,$个顶点的最小有根图恰有$\,n-1\,$条边

### 一些概念

#### 子图、连通子图

**子图**定义：对于图$\,G=(V,E)\,$和图$\,G' = (V',E')\,$，如果$\,V' \subseteq V \,\&\, E' \subseteq E\,$,则$\,G'\,$是$\,G\,$的一个子图

**连通子图**定义：一个图可能不是连通图(强连通图)，但它的一些子图可能是连通的(强连通的)，这种子图称为原图的连通子图(对于有向图，是强连通子图)

**连通分量**：无向图的一个极大连通子图(即子图的顶点和边集合都不能扩充，扩充之后不连通)

**强连通分量**：有向图的一个极大强连通子图

#### 带权图和网络

**带权图**定义：图的每条边都被赋予一个权值

**网络**定义：带权的连通无向图

### 图的表示

#### 邻接矩阵

最简单的邻接矩阵是
$$
    A_{ij} = \begin{cases}
        1, &v_i到v_j有边 \\
        0, &v_i到v_j无边
    \end{cases}
$$
对于带权图
$$
    A_{ij}= \begin{cases}
        \omega(i,j),&v_i到v_j有边,权为\omega(i,j)\\
        0/\infty, & v_i到v_j无边
    \end{cases}
$$
无向图的邻接矩阵都是**对称阵**

邻接矩阵的缺点：**稀疏**，有信息的元素比例不大，大量元素表示无边的值。空间浪费非常大，检查整个矩阵花费**顶点数量平方**的时间，而且进行扩充很麻烦

为了提高效率，可以采用其他的技术，如

- 邻接表
- 邻接多重表
- 图的十字链表

#### 邻接表

即为为图中的每个顶点**关联一个边表**，边表中记录这个顶点的所有邻接边。

因此图就由**一个顶点的表**和**每个顶点关联的表**组成。类似于树中的**父结点表示法**，可以用顺序表或链表实现

## 图的实现

### 邻接矩阵实现

### 邻接表实现

## 图算法

### 图的遍历

#### 会遇到的问题

①

一般的图未必是连通图。

基于图的遍历只能从一个(或几个)顶点出发，只能访问顶点所在的**连通分量(有向图是该顶点的可达子图)**里的全部顶点。但因为图未必连通，在完成一个可达部分的遍历之后，还需要考虑**对图中尚未遍历的部分的处理**

②

图与树不同，图中到达同一个顶点的路径可能不止一条，还可能存在回路。因此，在遍历时必须**避免多次处理同种同一部分的潜在问题**，在[栈与队列](栈和队列.md)中的**迷宫问题**中介绍过，可以采用对顶点进行0/1标记的方式，确定顶点是否被访问过

#### DFS

1. 首先访问顶点$\,v\,$，并将其标记为已访问
2. 检查$\,v\,$的邻接顶点，从中选一个尚未访问的顶点，从它出发继续进行搜索(递归)，不存在这种邻接结点时回溯
3. 从$\,v\,$出发的可达的所有顶点都已访问
4. 如果图中还存在未访问的顶点，则选出一个未访问的顶点，继续DFS

通过DFS得到的顶点序列称为该图的DFS序列

非递归dfs代码算法复杂度分析(图的算法复杂度基于顶点数$\,V\,$和边数$\,E\,$分析)

时间复杂度：

构造``visited``表和``dfs_seq``表时间复杂度$\,O(V)\,$。

入栈出栈的次数对应图中边数，总开销$\,O(E)\,$

遇到一个未访问顶点时要构造对应的**出度**表：对于邻接矩阵，构造所有边表的开销$\,O(V^2)\,$；对于邻接表，取出边的开销$\,O(E)\,$

由于$\,E \leq V^2\,$。综上，对于邻接矩阵的时间复杂度为$\,O(V^2)\,$,对于邻接表的时间复杂度为$\,O(max(V,E))\,$

空间复杂度：

``visited``表和``dfs_seq``空间开销$\,O(V)\,$，栈的深度也不会超过顶点个数

算法的空间复杂度为$\,O(V)\,$

#### BFS

1. 首先访问顶点$\,v_i\,$，并将其标记为已访问
2. 依次访问$\,v_i\,$的所有相邻顶点$\,v_{i_0},v_{i_1},\cdots,v_{i_{m-1}}\,$，在依次访问与$\,v_{i_0},v_{i_1},\cdots,v_{i_{m-1}}\,$邻接的所有尚未访问过的顶点。如此进行下去直到所有可达顶点都已访问
3. 如果图中还存在未访问的顶点，则选出一个未访问的顶点，继续BFS

通过BFS得到的顶点序列称为该图的BFS序列

#### 生成树

在本节讨论的都是**连通无向图**和**强连通有向图**

关于**生成森林**的概念是对于**非连通图**来说的，见[blog](http://c.biancheng.net/view/3406.html)

**性质**：图$\,G\,$有$\,n\,$个顶点，必然可以找到$\,G\,$中一个包含$\,n-1\,$条边的边集合，这个集合里包含了从$\,v_0\,$到其他所有顶点的路径。

该子图$\,T\,$中有$\,n\,$个顶点，包含$\,n-1\,$条边，所以它不可能包含任何回路，形成了一棵树。称$\,T\,$是$\,G\,$的一棵生成树

遍历用DFS和BFS即可

### 最小生成树(Minimum Spanning Tree, MST)

图中权值最小的生成树

#### Kruskal算法

$\,G=(V,E),\mid V \mid = n\,$

步骤：

1. 初始取$\,G\,$中所有顶点的孤立点子图$\,T=(V,\emptyset)\,$,$\,T\,$中的每个顶点自成一个连通分量。通过不断扩充$\,T\,$的方式构造最小生成树
2. 将边集$\,E\,$中的边按权值递增的顺序排序，每一步都要找到连接两个不同的连通分量的权值最小的边，将该边加入$\,T\,$。
3. 每次执行操作2都会使$\,T\,$减少一个连通分量，重复执行操作2，直到$\,T\,$中所有顶点都包含在一个连通分量里，这个连通分量就是$\,G\,$的一棵最小生成树

如果上述做法不能得到一个包含$\,G\,$所有顶点的连通分量，则原图不连通，没有最小生成树，算法做出的是最小连通森林

要解决的问题：

① 最短边的选取——优先队列，排序后顺序选取

② 判断两个顶点在$\,T\,$中属于不同连通分量——**每一个连通分量确定一个代表元**，如果两个顶点的代表元相同，则属于同一个连通分量。如果两个分量不属于同一连通分量，则在合并过程中，令一个分量的代表元的值=另一个分量的代表元的值

代码实现

复杂度分析

**时间复杂度**分析

- 建立边表``edges``$\,O(E)\,$，排序时间$\,O(E\log E)\,$(Python中内置排序函数确定)
- 主循环中的操作分为：进入条件体和不进入。整个循环体时间是$\,O(E)\,$；进入条件体的次数最多为$\,V-1\,$次，条件体内的循环时间为$\,O(V)\,$，所以条件体耗时$\,O(V^2)\,$;所以主循环的复杂度为$\,O(max(E\log E, V^2)) = O(V^2) \,\, \text{because} \, E \leq V^2\,$

总的时间复杂度$\,O(max(E\log E,V^2))\,$

**空间复杂度**分析：

共三个表``edges``(边数决定)，``reps``和``mst``(由顶点数决定)，空间复杂度$\,O(max(E,V))\,$。如果处理的是连通图，总有$\,O(E) \geq O(V)\,$,所以空间复杂度为$\,O(E)\,$

#### Prim算法

基于MST的重要性质：

在连通图$\,G=(V,E)\,$中，$\,U\,$是$\,V\,$的真子集，对于边$\,e=(u,v),u\in U, v\in V-U\,$且边$\,e\,$权值最小，则图必有一棵包含边$\,e\,$的MST

基本思想：从一个顶点出发，利用上述性质，选择最短连接边，扩充已连接的顶点集并加入所选的边，直到结点集合里包含图中所有顶点

复杂度分析

**时间复杂度**分析: 看不懂 先不写

### 最短路径

#### Dijkstra算法(求解单源点最短路)

思想与Prim算法类似

复杂度分析

#### Floyd算法(求解多源点最短路)

思想就是：不断的比较 在两个顶点$\,v_i\,$$\,v_j\,$之间插入0个顶点，1个顶点，...，n个 得到的最短路径不断地迭代

实现：

用递推的方式生成一系列$\,n\times n\,$方阵$\,A_k (0 \leq k \leq n)\,$,其中$\,A_k [i][j]\,$表示从顶点$\,v_i\,$到顶点$\,v_j\,$途径顶点可为$\,v_0,v_1,\cdots, v_{k-1}\,$的最短路径的长度。特别的$\,A_0\,$就是图$\,G\,$的邻接矩阵

- $\,A_0 [i][j]\,$可由邻接矩阵直接得到
- 对一般的$\,k\,$，$\,A_{k+1} [i][j] = min \{ A_k [i][j] , A_k [i][k]+A_k [k][j] \}, \, 0 \leq k \leq n-1\,$,得到的结果就是从顶点$\,v_i\,$到顶点$\,v_j\,$途径顶点下标不大于$\,k\,$的最短路径的长度
- 递推到最后，$\,A_n [i][j]\,$是从顶点$\,v_i\,$到顶点$\,v_j\,$的最短路径

还要求给出所有最短路径，用一个$\,n\times n\,$方阵$\,N_k\,$表示，其中$\,N_k [i][j]\,$的值是从顶点$\,v_i\,$到顶点$\,v_j\,$途径顶点下标不大于$\,k\,$的最短路径上，顶点$\,v_i\,$的后继顶点的下标

- 初始时，如果$\,A_0 [i][j]= \infty\,$,则令$\,N_0 [i][j]=-1\,$，否则令$\,N_0 [i][j]=j\,$
- 在由$\,v_k\,$计算$\,A_{k+1}\,$时，如果$\,A_{k+1} [i][j]\,$被设为$\, A_k [i][k]+A_k [k][j]\,$,就设置$\, N_{k+1} [i][j] = N_k [i][k]\,$,表示在$\,v_i\,$到$\,v_j\,$的路径上$\,v_i\,$的后继顶点，就是$\,v_i\,$到$\,v_k\,$的路径上$\,v_i\,$的后继顶点

复杂度分析很简单

时间复杂度：

三个嵌套循环$\,O(n^3)\,$

空间复杂度：

两个$\,n\times n\,$矩阵 $\,O(n^2)\,$

### AOV/AOE网(关于有向图)

#### AOV网

用图中的顶点表示某个“工程”里的不同活动，用图中的边表示各项活动之间的先后顺序关系，这样的图称为**顶点活动图(activity on vertex network)**,或称AOV网

一种AOV网的示例：大学课程的先修关系——学生想选修某门课程时，要看是否已修过所有先修课程

![AOV网实例part1](Snapshots\AOV网实例part1.PNG "AOV网实例part1")

![AOV网实例part2](Snapshots\AOV网实例part2.PNG "AOV网实例part2")

#### AOV网的拓扑排序

定义：

对于给定的AOV网$\,N\,$，如果$\,N\,$中所有顶点能排成一个线性序列
$$
    S = v_{i_0},v_{i_1},\cdots, v_{i_{n-1}}
$$
满足：如果$\,N\,$中存在从顶点$\,v_i\,$到顶点$\,v_j\,$的路径，则在$\,S\,$里$\,v_i\,$就排在$\,v_j\,$前面，称$\,S\,$是$\,N\,$的一个拓扑序列，构造拓扑序列的操作称为拓扑排序

一个AOV网未必有拓扑序列，一个AOV网存在拓扑序列，当且仅当它**不包含回路**(因为存在回路意味着某些活动的开始要以**自己的完成**作为先决条件，这种现象称为活动间的**死锁**)，下图为两个不存在拓扑序列的AOV网

![无拓扑序列的AOV网](Snapshots\无拓扑序列的AOV网.PNG "无拓扑序列的AOV网")

将拓扑序列反向得到的序列，是AOV网的**逆网**(把原来的AOV网的每条边反转)的一个**拓扑序列**

#### AOE(activity on edge network)网

AOE网中顶点表示**事件**，有向边表示**活动**，边上的权值通常表示活动的持续时间

关于**顶点表示的事件**，就是把它的**入边**所表示的活动**都已完成，它的出边所表示的活动可以开始的状态

下图是一个例子

![AOE网](Snapshots\AOE网.PNG "AOE网")

注意：AOE网中描述的活动可以并行的进行，只要一项活动(一条边)的前提事件均已发生(即以该边始点为**终点**的所有活动都已完成)，这项活动就可以开始

$\,\Rightarrow\,$ 完成整个工程的最短时间，就是从开始顶点到完成顶点的**最长路径**的长度(即路径上各条边的权值之和最大，因为如上所说，一项活动的开始必须要它的前提事件均发生，因此要等花费时间最长即权值最大的活动的结束)。这样的最长路径称为AOE网的**关键路径**

**算法思想**：

对于AOE网$\,G=(V,E)\,$,假定$\,v_0\,$是$\,G\,$中的开始事件，$\,v_{n-1}\,$是结束事件，$\,w(<v_i,v_j>)\,$为边$\,<v_i,v_j>\,$的权

① 定义**事件最早可能发生时间**：从源点顺推
$$
    ee[0] = 0(初始事件总在时刻0发生) \\
    ee[j] = max\{ee[i]+w(<v_i,v_j>) | <v_i,v_j> \in E\}, 1 \leq j \leq n-1
$$
② 定义**事件最迟允许发生时间**：从终点逆推
$$
    le[n-1] = ee[n-1] (最后一个时间不能延迟) \\
    le[i] = min\{le[j]-w(<v_i,v_j>)| <v_i,v_j> \in E\} , 0 \leq i \leq n-2(不能取最大，若取最大，le[i]加上某个权值可能会大于已经计算出来的le[j])
$$
③ 在这个网络中的活动$\,a_k=<v_i,v_j>\,$的最早可能开始时间$\,e[k]=ee[i]\,$,最迟允许开始时间$\,l[k]=le[j]-w(<v_i,v_j>)\,$(只要活动开始时间不晚于此时间，则不会拖延整个工程的工期)

④ 活动集合$\,A=\{a_k|e[k]=l[k]\}\,$中的所有活动称为这个AOE网的**关键活动**，他们中任何一个推迟开始都会延误工程的工期，集合$\,E-A\,$中的活动为**非关键活动**，非关键活动显然有$\,l[k]-e[k] > 0\,$，这个差值为活动$\,a_k\,$的**时间余量**，即活动$\,a_k\,$的开始时间可以推迟。

⑤ 所有**完全由关键活动**构成的从初始点到终点的路径就是AOE网的**关键路径**。i.e. 关键路径可能不止一条

得出$\,ee[i]和le[i]\,$的具体例子如下，其中关键活动用粗线标出

![AOE网关键路径](Snapshots\AOE网关键路径.PNG "AOE网关键路径")