- [字典和集合](#%e5%ad%97%e5%85%b8%e5%92%8c%e9%9b%86%e5%90%88)
  - [字典的线性表实现](#%e5%ad%97%e5%85%b8%e7%9a%84%e7%ba%bf%e6%80%a7%e8%a1%a8%e5%ae%9e%e7%8e%b0)
    - [有序线性表和快速检索](#%e6%9c%89%e5%ba%8f%e7%ba%bf%e6%80%a7%e8%a1%a8%e5%92%8c%e5%bf%ab%e9%80%9f%e6%a3%80%e7%b4%a2)
    - [总结线性表实现字典](#%e6%80%bb%e7%bb%93%e7%ba%bf%e6%80%a7%e8%a1%a8%e5%ae%9e%e7%8e%b0%e5%ad%97%e5%85%b8)
  - [散列与散列表](#%e6%95%a3%e5%88%97%e4%b8%8e%e6%95%a3%e5%88%97%e8%a1%a8)
    - [散列表的冲突](#%e6%95%a3%e5%88%97%e8%a1%a8%e7%9a%84%e5%86%b2%e7%aa%81)
    - [散列函数的设计](#%e6%95%a3%e5%88%97%e5%87%bd%e6%95%b0%e7%9a%84%e8%ae%be%e8%ae%a1)
    - [常用的散列函数](#%e5%b8%b8%e7%94%a8%e7%9a%84%e6%95%a3%e5%88%97%e5%87%bd%e6%95%b0)
      - [除余法](#%e9%99%a4%e4%bd%99%e6%b3%95)
      - [基数转换法](#%e5%9f%ba%e6%95%b0%e8%bd%ac%e6%8d%a2%e6%b3%95)
    - [冲突的解决](#%e5%86%b2%e7%aa%81%e7%9a%84%e8%a7%a3%e5%86%b3)
      - [内消解——开地址法](#%e5%86%85%e6%b6%88%e8%a7%a3%e5%bc%80%e5%9c%b0%e5%9d%80%e6%b3%95)
      - [外消解](#%e5%a4%96%e6%b6%88%e8%a7%a3)
  - [集合](#%e9%9b%86%e5%90%88)
    - [线性表实现](#%e7%ba%bf%e6%80%a7%e8%a1%a8%e5%ae%9e%e7%8e%b0)
    - [散列表实现](#%e6%95%a3%e5%88%97%e8%a1%a8%e5%ae%9e%e7%8e%b0)
    - [位向量实现](#%e4%bd%8d%e5%90%91%e9%87%8f%e5%ae%9e%e7%8e%b0)
  - [二叉排序树和字典](#%e4%ba%8c%e5%8f%89%e6%8e%92%e5%ba%8f%e6%a0%91%e5%92%8c%e5%ad%97%e5%85%b8)
    - [二叉排序树](#%e4%ba%8c%e5%8f%89%e6%8e%92%e5%ba%8f%e6%a0%91)
      - [定义](#%e5%ae%9a%e4%b9%89)
      - [二叉排序树的检索(好好理解遍历的代码)](#%e4%ba%8c%e5%8f%89%e6%8e%92%e5%ba%8f%e6%a0%91%e7%9a%84%e6%a3%80%e7%b4%a2%e5%a5%bd%e5%a5%bd%e7%90%86%e8%a7%a3%e9%81%8d%e5%8e%86%e7%9a%84%e4%bb%a3%e7%a0%81)
      - [二叉排序树的插入(要好好理解以下代码)](#%e4%ba%8c%e5%8f%89%e6%8e%92%e5%ba%8f%e6%a0%91%e7%9a%84%e6%8f%92%e5%85%a5%e8%a6%81%e5%a5%bd%e5%a5%bd%e7%90%86%e8%a7%a3%e4%bb%a5%e4%b8%8b%e4%bb%a3%e7%a0%81)
      - [二叉排序树的删除(好好理解代码)](#%e4%ba%8c%e5%8f%89%e6%8e%92%e5%ba%8f%e6%a0%91%e7%9a%84%e5%88%a0%e9%99%a4%e5%a5%bd%e5%a5%bd%e7%90%86%e8%a7%a3%e4%bb%a3%e7%a0%81)
      - [二叉排序树的算法分析](#%e4%ba%8c%e5%8f%89%e6%8e%92%e5%ba%8f%e6%a0%91%e7%9a%84%e7%ae%97%e6%b3%95%e5%88%86%e6%9e%90)
      - [检索概率相同时的最佳二叉排序树](#%e6%a3%80%e7%b4%a2%e6%a6%82%e7%8e%87%e7%9b%b8%e5%90%8c%e6%97%b6%e7%9a%84%e6%9c%80%e4%bd%b3%e4%ba%8c%e5%8f%89%e6%8e%92%e5%ba%8f%e6%a0%91)
      - [一般情况的最佳二叉排序树——动态规划](#%e4%b8%80%e8%88%ac%e6%83%85%e5%86%b5%e7%9a%84%e6%9c%80%e4%bd%b3%e4%ba%8c%e5%8f%89%e6%8e%92%e5%ba%8f%e6%a0%91%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92)
      - [最佳二叉排序树优缺](#%e6%9c%80%e4%bd%b3%e4%ba%8c%e5%8f%89%e6%8e%92%e5%ba%8f%e6%a0%91%e4%bc%98%e7%bc%ba)
  - [平衡二叉(排序)树(AVL树)](#%e5%b9%b3%e8%a1%a1%e4%ba%8c%e5%8f%89%e6%8e%92%e5%ba%8f%e6%a0%91avl%e6%a0%91)
    - [AVL树概念](#avl%e6%a0%91%e6%a6%82%e5%bf%b5)
    - [AVL树插入操作](#avl%e6%a0%91%e6%8f%92%e5%85%a5%e6%93%8d%e4%bd%9c)
    - [AVL删除操作 要看代码！！！](#avl%e5%88%a0%e9%99%a4%e6%93%8d%e4%bd%9c-%e8%a6%81%e7%9c%8b%e4%bb%a3%e7%a0%81)
  - [红黑树(还未学)](#%e7%ba%a2%e9%bb%91%e6%a0%91%e8%bf%98%e6%9c%aa%e5%ad%a6)
  - [动态多分支排序树](#%e5%8a%a8%e6%80%81%e5%a4%9a%e5%88%86%e6%94%af%e6%8e%92%e5%ba%8f%e6%a0%91)
    - [B树](#b%e6%a0%91)
    - [B+树](#b%e6%a0%91-1)

# 字典和集合

👉 生成目录 Ctrl+Shift+P => ctoc => create table of contents

关于检索效率的评价标准，通常是用**平均检索长度(ASL)**代表，定义如下
$$
    ASL = \sum_{i=0}^{n-1} p_i c_i, \,\,n是字典中的数据项数\\
    c_i和p_i分别为第i项数据元素的检索长度和检索概率\\
    若字典中各元素的检索概率相同，即p_i = \frac{1}{n} \Rightarrow ASL= \frac{1}{n} \sum_{i=0}^{n-1} c_i
$$

## 字典的线性表实现

用list实现，操作基于list的方法，如``pop``,``append``等

**时间复杂度分析**：

对于插入操作，如果直接``append``，不检查重复，时间复杂度为$\,O(1)\,$

对于删除操作(若是根据key进行删除)，需要检索后``pop``，时间复杂度$\,O(n)\,$

最重要的检索操作，考虑ASL,假设每项被检索到的概率相同
$$
    \begin{aligned}
        ASL&= 1\times p_0 + 2\times p_1 + \cdots + n\times p_{n-1}
    = \frac{1}{n} (1+2+\cdots+n) \\
    & = \frac{n+1}{2} \\
    & = O(n)
    \end{aligned}
$$

基于线性表的字典的**优点**：

实现简单，检索、删除操作中需要比较key，并不要求关键码集合存在某种顺序关系(如汉语字典中的顺序)

基于线性表的字典的**缺点**：

① 平均检索效率低，是线性耗时。

② 删除操作效率低，不太适合变动频繁的字典

但是对于**有序的线性表**(如整数的大小序，字符串的字典序等)，可以通过**二分法**实现快速检索

### 有序线性表和快速检索

**基本思想**：按比例逐步缩小需要考虑的数据范围，快速逼近要找的数据

**基本操作**：

① 初始时，考虑的元素区间是整个字典

② 取所考虑元素区间的中间位置的key，与要检索的key比较，如果相等，检索结束

③ 如果要检索的key较大，将检索范围改为后半区间；反之为前半区间

④ 如果检索范围内仍有数据则回到②继续，否则检索失败

**时间复杂度分析**：

① 检索过程即为一个**二叉树**，树的高度不会超过$\,\log_2 n\,$，所以时间复杂度为$\,O(\log n)\,$

② 虽然插入和删除时也可以用二分法达到$\,O(\log n)\,$的复杂度，但操作完成后要移动元素保持表的顺序，这种移动是逐项的移动，需要线性时间，所以插入和删除操作的复杂度还是$\,O(n)\,$

**二分法的缺陷**：

只能用于关键码可以排序、数据项按关键码排序的字典，而且只适用于**顺序存储结构，需要连续的存储块**。且不能支持动态变化的字典(插入和删除操作仍为线性时间)

### 总结线性表实现字典

不适用于**字典规模大**、**动态变化**。

如果不用二分法，效率太低。如果用二分法,不能很好的支持数据变化，而且需要连续的存储块

为了满足上述需求，字典的结构主要分为两类：

① 基于散列(hash)的**散列表**，也称哈希表

② 基于**各种树形结构**的数据存储和检索(树结构的特性——在深度不大的范围内可以容纳巨大数量的结点)

## 散列与散列表

在计算机的存储结构中，如果数据项连续存储，key就是**存储数据的地址**，在这种情况下，只需要**常量时间**就可以得到数据

但是，key可能不是整数，不能做下标。就算是整数，也会出现下面这个例子的情况：中国的身份证号码是18位整数，如果将其作为数据存储的下标，相关的顺序表就需要$\,10^{18}\,$个位置，但中国人口的数量级为$\,10^{9}\,$,这个表的填充率极低，为$\,10^{-9}\,$

**散列表的基本思想**就基于此：

将一种**不能或不适合**作为**数据存储的下标**的key，通过一个**变换**，将它们映射到一种下标，这样就将基于key的检索转变为**基于整数下标的直接元素访问**，有可能得到一种高效的字典。

**散列表**的实现方法：

① 选定一个整数的下标范围(通常以0或1开始)，建立一个包括相应元素范围的顺序表

② 选定一个**从key集合**到上述下标范围的映射$\,h\,$

在需要存储键为key的数据时，存入表的第$\,h(key)\,$个位置

需要检索键为key的数据时，直接去找的第$\,h(key)\,$个位置的数据

这个$\,h\,$称为**散列函数**，也称哈希函数

Python的内置类型dict就是基于散列表实现的

### 散列表的冲突

假设key是10个以内的英文字符串，key集合的规模的数量级为$\,10^{14}\,$,显然不能将其直接对应字典的下标

在实现散列表时，通常都有
$$
    \mid KEY \mid >> \mid INDEX \mid
$$
即key集合的规模远大于下标集合的规模。

所以在这种情况下，散列函数是一个从大集合到小集合的映射(**key集合对应定义于，下标集合对应值域**)，显然**不可能是单射**，必然会下述情况
$$
    key_1 \neq key_2 ,\,\,but \,\, h(key_1)=h(key_2)
$$
出现上述情况，就说这里出现了**冲突(或碰撞)**，也称$\,key_1\,$和$\,key_2\,$是$\,h\,$的**同义词**

为了度量出现冲突的可能性，提出了**负载因子**的概念
$$
    \alpha = \frac{散列表中当时的实际数据项数}{散列表的基本存储区能容纳的元素个数}
$$
显然，负载因子恒不大于1，负载因子越大，出现冲突的概率越大。但是如果扩大散列表的存储空间，可以降低负载因子，但负载因子越小，说明散列表中空闲空间的比列越大

综上，实现基于散列表技术的字典，必须解决两大问题：散列函数的设计；冲突消解机制

### 散列函数的设计

KEY和INDEX是两个有限集，分别为散列函数的定义域和值域。只要
$$
    \forall key \in KEY, f(key) \in INDEX
$$
都可以算作KEY的散列函数，但是不同的散列函数，出现冲突的概率不同

所以设计散列函数最重要的就是，尽可能减少出现冲突的可能性。

此外，散列函数的设计要尽可能消除key与散列值之间的规律性，即映射关系越乱越好

下面是几种基于整数key的散列方法

① 数字分析法

有点nt,即基于key的特征分析

![散列数字分析法](Snapshots\散列数字分析法.PNG "散列数字分析法")

② 折叠法

将较长的key切分为几段，通过某种运算将它们合并。

![散列折叠法](Snapshots\散列折叠法.PNG "散列折叠法")

③ 中平法

求出关键码的平方，然后取中间记为作为散列值

![散列中平法](Snapshots\散列中平法.PNG "散列中平法")

### 常用的散列函数

除余法：适用于整数key

基数转换法：适用于整数或字符串key

实际中，整数key和字符串key是最常用的两种key

#### 除余法

**思想**：

key是整数，用key➗某个不大于散列表长度$\,m\,$的整数$\,p\,$，得到的余数(或余数加$\,l\,$，若下标从1开始，则$\,l=1\,$)作为散列地址

为了存储方便 ，通常将$\,m\,$取为2的幂值，此时$\,p\,$可以取小于$\,m\,$的最大素数。

因为如果用偶数作为除数，就会出现偶数key映射到偶数散列值，奇数key映射到奇数散列值。前面说过，映射关系越乱越好

#### 基数转换法

**思想**：

对于整数key，对于一个key，将key看作$\,r\,$进制的数，通常$\,r\,$取素数以减少规律性，将其转换为二进制或十进制的数，如果转换后的数不符合下标范围，再通过除余法、折叠法etc，将其归入下标范围

对于字符串key，：将一个字符看作一个整数(可以直接用ASCII码值)，把一个字符串看作以某个整数为基数的“整数”。通常以**29或31**为基数，转换为整数后，再用整数的散列方法将其归入下标范围

### 冲突的解决

内消解方法：在存储区内部解决冲突

外消解方法：在存储区外部解决冲突

#### 内消解——开地址法

**基本思想**：

在准备插入数据并发现冲突时，在顺序表中为需要插入的数据项另外安排一个位置

因此需要设计一种**易于计算**的位置安排方式，称为**探查方式**

**基本方法**：

为散列表定义一种易于计算的**整数递增序列**
$$
    D = d_0,d_1,d_2,\cdots, \,\,\, d_0=0
$$
再定义探查序列
$$
    H_i = (h(key) + d_i) mod p, \text{  p是一个不超过表长度的整数}
$$
在插入过程中，如果$\,h(key)\,$位置空闲，则直接插入(相当于使用$\,d_0\,$)。否则就逐个试探$\,H_i\,$,直到找到一个空位。

关于整数递增序列的设计，可以有以下几种(只是举例)

① $\,D=0,1,2,3,\cdots\,$,称为线性探查

② 设计另一个散列函数 令$\,d_i = i \times h_2(key)\,$,称为双散列探查

**示例**：

![开地址示例](Snapshots\开地址示例.PNG "开地址示例")

![开地址示例2](Snapshots\开地址示例2.PNG "开地址示例2")

可以看到，随着表中数据的增加，产生冲突的可能性也不断增长。而且数据在表中**逐渐堆积成段**，使**线性探查序列变得越来越长**，使得字典的操作效率大大下降。

#### 外消解

**溢出区方法**：

发生冲突时将**相应数据和关键码**一起存入溢出区，数据在溢出区顺序排列。

缺点是随着溢出区的不断扩展，字典的性能趋于线性

**桶散列**：

下面是桶散列中最简单的设计：拉链法

在桶散列中，散列表的每个元素只是一个引用域，引用着一个**保存实际数据的存储桶**。在拉链法中，一个存储桶就是一个链表。遇到冲突时，将数据存储在这个散列值的存储桶中

## 集合

### 线性表实现

与字典类似

### 散列表实现

### 位向量实现

**实现方法**：

假定程序中的一批集合对象有一个**公共全集**$\,U\,$

① 假定$\,U\,$包含$\,n\,$个元素，给每个元素一个编号作为该元素的下标

② 对$\,U\,$的一个真子集$\,S\,$，用一个$\,n\,$位的二进制序列(位向量)$\,v_s\,$表示，$\,\forall e \in U,若e \in S\,$,则令$\,v_s\,$中对应$\,e\,$的位取值为1，若$\,e \notin S\,$,取0

位向量的集合的相关运算(并交等)，都可以通过逐位操作实现。

集合的位向量表示比较紧凑，空间利用率高。适用于全集$\,U\,$不是太大，且需要处理的是$\,U\,$的一批子集

## 二叉排序树和字典

### 二叉排序树

二叉排序树可以用于实现**关键码有序**的字典

之前的**二分检索**的判定树都是二叉排序树

#### 定义

- 其根结点保存着一个数据项(及其key)
- 如果其左子树不空，则其左子树的所有结点保存的key值**均小于**(不要求严格小于)根结点所保存的key值
- 如果其右子树不空，则其右子树所有结点保存的key值**均大于**(不要求严格大于)根结点保存的key值
- 非空的左子树和右子树也是二叉排序树

二叉排序树例子：
$$
    KEY=[36,65,18,7,60,89,43,57,96,52,74]
$$
![二叉排序树实例](Snapshots\二叉排序树实例.PNG "二叉排序树实例")

显然若对二叉排序树做**中序遍历**，得到的是一个按key值增序序列

#### 二叉排序树的检索(好好理解遍历的代码)

#### 二叉排序树的插入(要好好理解以下代码)

#### 二叉排序树的删除(好好理解代码)

要降低操作代价，要尽可能不破坏树的结构，只做局部的修改和调整

**算法思想**如下：

假设已经确定删除结点$\,q\,$,它是其父结点$\,p\,$的左子结点(为$\,p\,$的右子结点的情况类似)，此时有两种情况

① $\,q\,$是叶结点，这时直接将$\,p\,$对$\,q\,$的引用设置为``None``即可

② $\,q\,$不是叶结点，这时不能简单的删除，要考虑将$\,q\,$的子树连接到删除$\,q\,$之后的树上，同时还要保序

②中又可分为两种情况

a 如果$\,q\,$没有左子结点，直接将$\,q\,$的右子树改为$\,p\,$的左子树即可，如下图所示

![二叉排序树删除1](Snapshots\二叉排序树删除1.PNG "二叉排序树删除1")

b 如果$\,q\,$有左子结点，则先找到$\,q\,$的左子树中的最右结点(即在$\,q\,$的左子树中与$\,q\,$的key差值最小的结点)，记为$\,r\,$，然后**用$\,q\,$的左子结点代替$\,q\,$作为$\,p\,$的左子结点，并将$\,q\,$的右子树作为$\,r\,$的右子树**，如下图所示

![二叉排序树删除2](Snapshots\二叉排序树删除2.PNG "二叉排序树删除2")

Q：这里为啥不能直接在右子树里找到最左的结点替换,上述操作会增加树的高度(我实现了，但是代码量增加了，要考虑好多种情况，虽然再次检索，但是复杂度不会超过$\,O(\log n)\,$,复杂度保持不变)

#### 二叉排序树的算法分析

二叉排序树的主要操作：检索、插入、删除。

其中插入和删除都是基于**检索**

根据二叉树的性质，在[二叉树与树](二叉树与树.md)中有，复杂度为$\,O(\log n)\,$

#### 检索概率相同时的最佳二叉排序树

提出**最佳二叉排序树**是基于这样一个问题：如果一般的二叉排序树出现**检索路径**特别长的情况 $\,\Rightarrow\,$对于一组给定的key，最好的二叉排序树是什么样？这个评价标准显然应基于**检索效率**，或可以给出**平均检索长度**来判断排序二叉树的优劣

这里再引出[扩充二叉树](二叉树与树.md)的概念，**成功检索**可以对应扩充二叉树的**内部结点**，**失败检索**可以对应扩充二叉树的**外部结点**，如下图所示

![二叉排序树及扩充二叉树](Snapshots\二叉排序树及扩充二叉树.PNG "二叉排序树及扩充二叉树")

按照**中序遍历**的这种扩充二叉树，得到的结点序列里**内部和外部结点交叉排列**，如果从0开始分别标记内部结点和外部结点，第$\,i\,$个内部结点位于第$\,i\,$个外部结点和第$\,i+1\,$个外部结点之间。这样的**结点标记序列**称为**扩充二叉排序树的对称序列**

在这种扩充二叉排序树种，key的**平均检索长度**
$$
    E(n) = \frac{1}{\omega} [\sum_{i=0}^{n-1} p_i(l_i+1) +\sum_{i=0}^{n} q_i l_i^{'}] \\
    \omega  = \sum_{i=0}^{n-1} p_i+ \sum_{i=0}^{n} q_i
$$
其中

- $\,n\,$是内部结点的个数，[排序二叉树的性质，外部结点比内部结点多一个](二叉树与树.md)，所以在求和符号上一个是$\,n-1\,$，一个是$\,n\,$
- $\,l_i\,$是内部结点$\,i\,$的层数，$\,l_i^{'}\,$是外部结点$\,i\,$的层数
- $\,p_i\,$是检索内部结点$\,i\,$的key的频度，确定一个内部结点，需要做的比较次数是结点所在层数加一(随便举个例子，很好理解)
- $\,q_i\,$是被检索的key属于外部结点$\,i\,$代表的key的集合的频度，检索达到一个外部结点的比较次数等于该结点所在的层数
- $\,p_i/\omega,q_i/\omega\,$可以分别看作**检索内部结点$\,i\,$的key的概率**和**被检索的key属于外部结点$\,i\,$的key集合的概率**，可以将$\,p_i/\omega,q_i/\omega\,$看作对应结点的**权**

所以综上，**最佳二叉排序树**就是$\,E(n)\,$最小的树

若考虑最简单的情况：**检索概率相同**，令$\,p_i,q_i = 1 \Rightarrow \omega = 2n+1\,$,有
$$
    \begin{aligned}
        E(n) & = \frac{1}{2n+1}[\sum_{i=0}^{n-1} (l_i+1) +\sum_{i=0}^{n} l_i^{'}] \\
        &= (IPL + n + EPL) / (2n+ 1) \text{\,\,\,\,\,\,i.e.} EPL = IPL + 2 \times n \\
    \end{aligned}
$$
$$
    IPL = \sum_{k=1}^{n} [\log_2 k] =
    (n+1)[\log_2 n] - 2^{[\log_2 n ] +1 } + 2
$$
由$\,IPL\,$可知，高度越低的树越好

所以构造最佳二叉排序树的**基本思想**就是：左右子树的结点均分。因为二叉树是递归结构，用递归定义很简单(类似于二分法)

#### 一般情况的最佳二叉排序树——动态规划

$$
    E(0,n) = \sum_{i=0}^{n-1} p_i(l_i+1) +\sum_{i=0}^{n} q_i l_i^{'} \\
    E(0,n)是包含n个内部结点和n+1个外部结点的树的带权路径长度
$$

由于搜索频度的差异，高度最低的树未必最优。下图中左边树的搜索路径长度为53，右边为45

![一般的最佳二叉排序树](Snapshots\一般的最佳二叉排序树.PNG "一般的最佳二叉排序树")

**构造方法**：

先定义一些记法：

$\,T(i,j)\,$表示包含内部结点$\,v_i,\cdots,v_{j-1}\,$和相应外部结点$\,e_i,\cdots,e_{j-1},e_j\,$的最佳二叉排序树。显然这是扩充二叉排序树对称序列的一段

$\,E(i,j)\,$表示这棵最佳二叉排序树的权值

什么是**动态规划**：

问题较复杂，无法直接得到结果时。通过逐步推进，在每步计算中根据已知的信息做一些选择，得到一些局部结果，这样积累了信息，也为下一步计算做好准备

Dijkstra算法就是一个典型，每一步计算都维护某一顶点到其他顶点的最短路径。

算法也是基于这样的思路，从**最小的最佳排序二叉树**开始，逐步做出所需的最佳排序二叉树

下面结合下图的例子

![一般的最佳二叉排序树](Snapshots\一般的最佳二叉排序树.PNG "一般的最佳二叉排序树")

Step1: 首先构造出只包含一个内部结点的最佳二叉排序树(由于只有一个内部结点，这样的树只有一棵，它本身自然是最佳二叉排序树)
$$
    \forall i \in [0,n],做出T(i,i+1),计算对应的E(i,i+1)=q_i + p_i + q_{i+1}\\
$$
就得到了n棵只包含一个内部结点的最佳二叉排序树

![一般的最佳二叉排序树2](Snapshots\一般的最佳二叉排序树2.PNG "一般的最佳二叉排序树2")

Step2：
$$
    \forall i \in [0,n-2],构造只包含内部结点v_i,v_{i+1}的最佳二叉排序树T(i,i+2)。
$$
对于构造$\,T(0,2)\,$为例，**注意，构造时每棵构造的树必须是最佳二叉排序树**，这时有两种可能
$$
    以v_0为新树的根，以e_0为左子树，以T(1,2)为右子树,E(0,2)=20 \\
    以v_1为新树的根，以T(0,1)为左子树，以e_2为右子树，E(0,2)= 17
$$

![一般的最佳二叉排序树3](Snapshots\一般的最佳二叉排序树3.PNG "一般的最佳二叉排序树3")

构造$\,T(1,3)\,$采用相同的方法构造，得到

![一般的最佳二叉排序树4](Snapshots\一般的最佳二叉排序树4.PNG "一般的最佳二叉排序树4")

Step3：
$$
    \forall i \in [0,n-3],构造只包含内部结点v_i,v_{i+1},v_{i+2}的最佳二叉排序树T(i,i+3)
$$

![一般的最佳二叉排序树5](Snapshots\一般的最佳二叉排序树5.PNG "一般的最佳二叉排序树5")

对于该例，$\,T(0,3)\,$就是最终结果

👉下面总结一般步骤

当构造进行到第$\,m(m\leq n)\,$时，对每个$\,i(0<i<m)\,$，前面的步骤已经构造出$\,n-i+1\,$棵包含$\,i\,$个内部结点的最佳二叉排序树：
$$
    T(0,i),T(1,i+1),\cdots,T(n-i,n)
$$
在第$\,m\,$步要基于上述每个$\,i\,$所形成的最佳二叉排序树构造出$\,n-m+1\,$棵包含$\,m\,$个内部结点的最佳二叉排序树：
$$
    T(0,m),T(1,m+1),\cdots,T(n-m,n)
$$
在构造每棵树的时候，要考虑所有的组合可能，从中选出最佳的一棵树

👉计算带权路径长度

在每一步中，都要算出所有可能组合的带权路径长度，可以通过遍历所有路径，但代价太高。

构造一棵最佳二叉排序树时，带权路径长度可以基于两棵子树的带权路径长度计算出

对于内部结点$\,v_i,v_{i+1},\cdots, v_{j-1}\,$，与之对应的**内外结点权值交错序列为**$\,q_i,p_i,q_{i+1},\cdots,p_{j-1},q_j\,$。可以计算出这段序列的权值之和$\,W(i,j)=p_i+p_{i+1}+\cdots+p_{j-1}+q_i+q_{i+1}+\cdots+q_j\,$,显然这种值**与树结构无关**，可以对每对$\,i,j\,$先算出留用

在构造树$\,T(i,j)\,$时，若以$\,k\,$为根，$\,\forall k \in (i,j-1) \quad 注意是开区间，即还不考虑Step3中左图和右图中的情况(k=i or k = j-1)\,$,所有的$\,T(i,k)和T(k+1,j)\,$都已经构造好，且带权路径长度已知，分别记为$\,E(i,k)和E(k+1,j)\,$，可以得出以$\,k\,$为根的最佳排序二叉树的带权路径长度
$$
    T(i,k)和T(k+1,j)两棵树作为根结点k的两棵子树，树中所有结点的层数均加一\\
    \begin{aligned}
        E_k(i,j)&= p_k+ \sum_{a=i}^{k-1} p_a (l_a+1) + \sum_{a=i}^{k} q_a(l_a^{'} + 1)+\sum_{b=k+1}^{j-1} p_b (l_b + 1) + \sum_{b=k+1}^{j}q_b(l_b^{'} + 1) \\
        &= p_k + \sum_{a=i}^{k-1} p_a + \sum_{a=i}^{k} q_a +\sum_{b=k+1}^{j-1} p_b +\sum_{b=k+1}^{j} q_b +\sum_{a=i}^{k-1} p_al_a+\sum_{a=i}^{k} q_al_a^{'} + \sum_{b=k+1}^{j-1} p_bl_b  + \sum_{b=k+1}^{j} q_bl_b{'}\\
        &= W(i,j) + E(i,k) + E(k+1,j)\\
        &\Rightarrow E(i,j) = W(i,j) + min\{E(i,k)+E(k+1,j) \mid i<k<j-1\}
    \end{aligned}
$$

显然，只包含一个内部结点的最佳二叉排序树带权路径长度可以直接算出，其他可以由👆公式递推得到。

👉 算法实现
$$
    r[i][j]记录构造出最佳子树T(i,j)的根结点下标\\
    e[i][j]记录子树T(i,j)的带权路径长度\\
    w[i][j]记录树中相应的内外结点权值交错序列的和\\
    由于i<j,所有上述矩阵都是上三角矩阵，维度均为n+1 \\
    矩阵w对角线上的值为外部结点的频度，其他元素可以递推得到\\
    矩阵r和c的主对角线不使用，算法从上副对角线开始，向右上方一层层计算\\
    最终得到的r[0][n]是最佳二叉排序树的根，若其根为k，可以追溯整个排序二叉树，左子树根结点编号在r[0][k],右子树根结点编号在r[k+1][n]
$$

👉 复杂度分析

时间复杂度$\,O(n^3)\,$，空间复杂度$\,O(n^2)\,$

#### 最佳二叉排序树优缺

👉 优点

保证最佳的检索效率

👉 缺点

需要掌握所有key，构造成本高

只适合静态字典的表示，在执行动态操作时**很难维护树的结构**，在进行一系列动态操作后，树的高度可能为$\,O(n)\,$

## 平衡二叉(排序)树(AVL树)

为了使树的结构可以很好的得到维护，即保证一定有$\,O(\log n)\,$的检索效率，发明了平衡二叉排序树。

所以平衡二叉排序树的基本考虑是：**如果树中每个结点的左右子树高度差不多(平衡)，整个树的结构会比较好，不会出现特别长的路径**

### AVL树概念

👉 定义

AVL树是一类特殊的二叉排序树，或为空树，或左右子树都是平衡二叉排序树(递归结构)，且左右子树的高度差不超过1

👉 平衡因子(Balance Factor，BF)

结点平衡用一个BF描述，定义为该结点左子树高度减去右子树高度之差。在平衡二叉树的结点中并不记录左右子树的高度，只记录BF值

### AVL树插入操作

👉 最小非平衡子树，距离插入结点最近的，且以BF值为1或-1的结点为根的子树

👉 不需要改变树结构

如果查找插入位置过程中，所有途径结点的BF值都为0，则插入新结点后，不会造成途径结点的失衡，但会改变它们的BF值，如下所示

![AVL插入1](Snapshots\AVL插入1.PNG "AVL插入1")

插入最小非平衡子树的较低子树，如下所示

![AVL插入1](Snapshots\AVL插入2.PNG "AVL插入2")

👉需要改变树结构：4种情况

👉 LL型调整：a的左子树较高，a是最小非平衡子树的根，新结点插入到了a的左子树的左子树

![AVL插入3](Snapshots\AVL插入3.PNG "AVL插入3")

将结点2-3-4-5-8看做可以转动的一条链，将其向右旋转一个结点，原来a的左子树的右子树连接到旋转后的a的左子树

👉 RR型调整：a的右子树较高，a是最小非平衡子树的根，新结点插入到a的右子树的右子树

![AVL插入4](Snapshots\AVL插入4.PNG "AVL插入4")

向左旋转一个结点，原来a的左子树的左子树连接到旋转后a的右子树(图中8对应的BF应该是-1，a对应的BF是0)

👉 LR型调整：a的左子树较高，a是最小非平衡子树的根，新结点插入在a的左子树的右子树

![AVL插入5](Snapshots\AVL插入5.PNG "AVL插入5")

先左旋转，再右旋转

先将c结点的左右子树摘下来，将结点2-3-4-4.5看成一条链，左旋转，再将2-3-4-4.5-5-8-9看成一条链，右旋转

![AVL插入6](Snapshots\AVL插入6.PNG "AVL插入6")

![AVL插入7](Snapshots\AVL插入7.PNG "AVL插入7")

👉 RL型调整：a的右子树较高，a是最小非平衡子树的根，新结点插入在a的右子树的左子树

![AVL插入8](Snapshots\AVL插入8.PNG "AVL插入8")

![AVL插入9](Snapshots\AVL插入9.PNG "AVL插入9")

![AVL插入10](Snapshots\AVL插入10.PNG "AVL插入10")

### AVL删除操作 要看代码！！！

比插入操作更复杂，涉及到回溯

👉 删除的结点可分为三类：叶结点，只有左子树或右子树，有两棵子树

👉 叶结点:又可分为左子叶结点和右子叶结点

👉 左子叶结点``p``，父结点``q`` (右子叶结点和左子叶结点只是位置不同，思路一样)

```python
    q.bf == 1 # 树变矮 要回溯
    q.bf == 0 # 不需要回溯 只需改变q.bf
    q.bf == -1 #进行调整，调整之后树高可能会变
```

其中``q.bf == -1``有以下三种情况：

$RL$:

![AVL树删除1](Snapshots\AVL树删除1.JPG "AVL树删除1")

调整后树的高度改变，要继续回溯

$RR1$：

![AVL树删除2](Snapshots\AVL树删除2.JPG "AVL树删除2")

调整后树的高度改变，要继续回溯

$RR2$:

![AVL树删除3](Snapshots\AVL树删除3.JPG "AVL树删除3")

调整后树的高度不改变，更改根结点的``bf``值，停止回溯

👉 只有左子树和只有右子树

👉 左右子树都有 转换为叶结点的问题

## 红黑树(还未学)

## 动态多分支排序树

### B树

### B+树
